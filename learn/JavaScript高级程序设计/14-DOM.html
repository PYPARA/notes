<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>14 DOM | PYPARA</title>
    <meta name="description" content="个人记录">
    <meta name="generator" content="VitePress v1.0.0-rc.44">
    <link rel="preload stylesheet" href="/notes/assets/style.CY2ccow2.css" as="style">
    
    <script type="module" src="/notes/assets/app.83FYqqNm.js"></script>
    <link rel="preload" href="/notes/assets/inter-roman-latin.Bu8hRsVA.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/notes/assets/chunks/framework.DhcZWzV3.js">
    <link rel="modulepreload" href="/notes/assets/chunks/theme.Bm6j8nIS.js">
    <link rel="modulepreload" href="/notes/assets/learn_JavaScript高级程序设计_14-DOM.md.DObm8Pld.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-19c990f1><div class="wrapper" data-v-19c990f1><div class="container" data-v-19c990f1><div class="title" data-v-19c990f1><div class="VPNavBarTitle" data-v-19c990f1 data-v-ab179fa1><a class="title" href="/notes/" data-v-ab179fa1><!--[--><!--]--><!----><span data-v-ab179fa1>PYPARA</span><!--[--><!--]--></a></div></div><div class="content" data-v-19c990f1><div class="content-body" data-v-19c990f1><!--[--><!--]--><div class="VPNavBarSearch search" data-v-19c990f1><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-19c990f1 data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/notes/learn/introduction.html" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>Learn</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/notes/reading/introduction.html" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>Reading</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/notes/blog/introduction.html" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>Blog</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/notes/notes/sites.html" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>Notes</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-19c990f1 data-v-e6aabb21><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-e6aabb21 data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-19c990f1 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/PYPARA" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-19c990f1 data-v-d0bd9dde data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b6c34ac9><span class="vpi-more-horizontal icon" data-v-b6c34ac9></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-d0bd9dde><div class="item appearance" data-v-d0bd9dde><p class="label" data-v-d0bd9dde>Appearance</p><div class="appearance-action" data-v-d0bd9dde><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-d0bd9dde data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div></div></div><div class="group" data-v-d0bd9dde><div class="item social-links" data-v-d0bd9dde><div class="VPSocialLinks social-links-list" data-v-d0bd9dde data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/PYPARA" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-19c990f1 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-19c990f1><div class="divider-line" data-v-19c990f1></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-d2ecc192><button data-v-d2ecc192>Return to top</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-3f215769 data-v-935f8a84><div class="content" data-v-935f8a84><div class="outline-marker" data-v-935f8a84></div><div class="outline-title" role="heading" aria-level="2" data-v-935f8a84>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-935f8a84><span class="visually-hidden" id="doc-outline-aria-label" data-v-935f8a84> Table of Contents for current page </span><ul class="VPDocOutlineItem root" data-v-935f8a84 data-v-b933a997><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _notes_learn_JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_14-DOM" data-v-39a288b8><div><h1 id="_14-dom" tabindex="-1">14 DOM <a class="header-anchor" href="#_14-dom" aria-label="Permalink to &quot;14 DOM&quot;">​</a></h1><ul><li>理解文档对象模型(DOM)的构成</li><li>节点类型</li><li>浏览器兼容性</li><li>MutationObserver 接口</li></ul><p>文档对象模型(DOM，Document Object Model)是 HTML 和 XML 文档的编程接口。DOM 表示 由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早期的动态 HTML(DHTML，Dynamic HTML)，DOM 现在是真正跨平台、语言无关的表示和操作网页的方式。</p><p>DOM Level 1 在 1998 年成为 W3C 推荐标准，提供了基本文档结构和查询的接口。本章之所以介绍 DOM，主要因为它与浏览器中的 HTML 网页相关，并且在 JavaScript 中提供了 DOM API。</p><h2 id="_14-1-节点层级" tabindex="-1">14.1 节点层级 <a class="header-anchor" href="#_14-1-节点层级" aria-label="Permalink to &quot;14.1 节点层级&quot;">​</a></h2><p>任何 HTML 或 XML 文档都可以用 DOM 表示为一个由节点构成的层级结构。节点分很多类型，每 种类型对应着文档中不同的信息和(或)标记，也都有自己不同的特性、数据和方法，而且与其他类型有某种关系。</p><p>document 节点表示每个文档的根节点。在这里，根节点的唯一子节点是<code>&lt;html&gt;</code>元素，我们称之 为文档元素(documentElement)。文档元素是文档最外层的元素，所有其他元素都存在于这个元素之内。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终是<code>&lt;html&gt;</code>元素。在 XML 文档中， 则没有这样预定义的元素，任何元素都可能成为文档元素。</p><p>HTML 中的每段标记都可以表示为这个树形结构中的一个节点。元素节点表示 HTML 元素，属性节点表示属性，文档类型节点表示文档类型，注释节点表示注释。DOM 中总共有 12 种节点类型，这些类型都继承一种基本类型。</p><h3 id="_14-1-1-node-类型" tabindex="-1">14.1.1 Node 类型 <a class="header-anchor" href="#_14-1-1-node-类型" aria-label="Permalink to &quot;14.1.1 Node 类型&quot;">​</a></h3><p>DOM Level 1 描述了名为 Node 的接口，这个接口是所有 DOM 节点类型都必须实现的。Node 接口 在 JavaScript 中被实现为 Node 类型，在除 IE 之外的所有浏览器中都可以直接访问这个类型。在 JavaScript 中，所有节点类型都继承 Node 类型，因此所有类型都共享相同的基本属性和方法。</p><p>每个节点都有 nodeType 属性，表示该节点的类型。节点类型由定义在 Node 类型上的 12 个数值常量表示:</p><ul><li>Node.ELEMENT_NODE(1)</li><li>Node.ATTRIBUTE_NODE(2)</li><li>Node.TEXT_NODE(3)</li><li>Node.CDATA_SECTION_NODE(4)</li><li>Node.ENTITY_REFERENCE_NODE(5)</li><li>Node.ENTITY_NODE(6)</li><li>Node.PROCESSING_INSTRUCTION_NODE(7)</li><li>Node.COMMENT_NODE(8)</li><li>Node.DOCUMENT_NODE(9)</li><li>Node.DOCUMENT_TYPE_NODE(10)</li><li>Node.DOCUMENT_FRAGMENT_NODE(11)</li><li>Node.NOTATION_NODE(12)</li></ul><p>节点类型可通过与这些常量比较来确定，比如:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (someNode.nodeType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Node.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ELEMENT_NODE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Node is an element.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个例子比较了 <code>someNode.nodeType</code> 与 <code>Node.ELEMENT_NODE</code> 常量。如果两者相等，则意味着 <code>someNode</code> 是一个元素节点。</p><p>浏览器并不支持所有节点类型。开发者最常用到的是元素节点和文本节点。本章后面会讨论每种节点受支持的程度及其用法。</p><ol><li>nodeName 与 nodeValue</li></ol><p><code>nodeName</code> 与 <code>nodeValue</code> 保存着有关节点的信息。这两个属性的值完全取决于节点类型。在使用这两个属性前，最好先检测节点类型，如下所示:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (someNode.nodeType </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.nodeName; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 会显示元素的标签名</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在这个例子中，先检查了节点是不是元素。如果是，则将其 <code>nodeName</code> 的值赋给一个变量。对元素而言，nodeName 始终等于元素的标签名，而 <code>nodeValue</code> 则始终为 <code>null</code>。</p><ol start="2"><li>节点关系</li></ol><p>文档中的所有节点都与其他节点有关系。这些关系可以形容为家族关系，相当于把文档树比作家谱。 在 HTML 中，<code>&lt;body&gt;</code>元素是<code>&lt;html&gt;</code>元素的子元素，而<code>&lt;html&gt;</code>元素则是<code>&lt;body&gt;</code>元素的父元素。<code>&lt;head&gt;</code>元素是<code>&lt;body&gt;</code>元素的同胞元素，因为它们有共同的父元素<code>&lt;html&gt;</code>。</p><p>每个节点都有一个 <code>childNodes</code> 属性，其中包含一个 <code>NodeList</code> <code>的实例。NodeList</code> 是一个类数组 对象，用于存储可以按位置存取的有序节点。注意，<code>NodeList</code> 并不是 <code>Array</code> 的实例，但可以使用中括号访问它的值，而且它也有 <code>length</code> 属性。<code>NodeList</code> 对象独特的地方在于，它其实是一个对 DOM 结构的查询，因此 DOM 结构的变化会自动地在 <code>NodeList</code> 中反映出来。我们通常说 <code>NodeList</code> 是实时的活动对象，而不是第一次访问时所获得内容的快照。</p><p>下面的例子展示了如何使用中括号或使用 <code>item()</code> 方法访问 <code>NodeList</code> 中的元素:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.childNodes[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> secondChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.childNodes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.childNodes.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>无论是使用中括号还是 item()方法都是可以的，但多数开发者倾向于使用中括号，因为它是一个 类数组对象。注意，length 属性表示那一时刻 NodeList 中节点的数量。使用 Array.prototype. slice()可以像前面介绍 arguments 时一样把 NodeList 对象转换为数组。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arrayOfNodes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">prototype</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.slice.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(someNode.childNodes,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>当然，使用 ES6 的 Array.from()静态方法，可以替换这种笨拙的方式:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> arrayOfNodes </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(someNode.childNodes);</span></span></code></pre></div><p>每个节点都有一个 <code>parentNode</code> 属性，指向其 DOM 树中的父元素。childNodes 中的所有节点都 有同一个父元素，因此它们的 parentNode 属性都指向同一个节点。此外，<code>childNodes</code> 列表中的每个 节点都是同一列表中其他节点的同胞节点。而使用 <code>previousSibling</code> 和 <code>nextSibling</code> 可以在这个列 表的节点间导航。这个列表中第一个节点的 <code>previousSibling</code> 属性是 null，最后一个节点的 <code>nextSibling</code> 属性也是 <code>null</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (someNode.nextSibling </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Last node in the parent&#39;s childNodes list.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (someNode.previousSibling </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;First node in the parent&#39;s childNodes list.&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>注意，如果<code>childNodes</code>中只有一个节点，则它的<code>previousSibling</code>和<code>nextSibling</code>属性都是 <code>null。</code></p><p>父节点和它的第一个及最后一个子节点也有专门属性:<code>firstChild</code> 和 <code>lastChild</code> 分别指向 <code>childNodes</code> 中的第一个和最后一个子节点。</p><ol start="3"><li>操纵节点</li></ol><p>因为所有关系指针都是只读的，所以 DOM 又提供了一些操纵节点的方法。最常用的方法是 <code>appendChild()</code>，用于在 <code>childNodes</code> 列表末尾添加节点。</p><p>如果把文档中已经存在的节点传给 <code>appendChild()</code>，则这个节点会从之前的位置被转移到新位置。 即使 DOM 树通过各种关系指针维系，一个节点也不会在文档中同时出现在两个或更多个地方。</p><p>如果想把节点放到 <code>childNodes</code> 中的特定位置而不是末尾，则可以使用 <code>insertBefore()</code> 方法。 这个方法接收两个参数:要插入的节点和参照节点。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 作为最后一个子节点插入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">returnedNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newNode, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.lastChild); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 作为新的第一个子节点插入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">returnedNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newNode, someNode.firstChild); </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(returnedNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newNode); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.firstChild); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 插入最后一个子节点前面</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">returnedNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newNode, someNode.lastChild);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">alert</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.childNodes[someNode.childNodes.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre></div><p><code>appendChild() </code>和 <code>insertBefore()</code> 在插入节点时不会删除任何已有节点。相对地， <code>replaceChild()</code> 方法接收两个参数:要插入的节点和要替换的节点。 要替换的节点会被返回并从文档树中移除，要插入的节点取而代之。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 替换第一个子节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> returnedNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replaceChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newNode, someNode.firstChild);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 替换最后一个子节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">returnedNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replaceChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newNode, someNode.lastChild);</span></span></code></pre></div><p>使用 <code>replaceChild()</code> 插入一个节点后，所有关系指针都会从被替换的节点复制过来。虽然被替换的节点从技术上说仍然被同一个文档所拥有，但文档中已经没有它的位置。</p><p>要移除节点而不是替换节点，可以使用 <code>removeChild()</code> 方法。这个方法接收一个参数，即要移除的节点。被移除的节点会被返回。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除第一个子节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> formerFirstChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(someNode.firstChild);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 删除最后一个子节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> formerLastChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someNode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(someNode.lastChild);</span></span></code></pre></div><ol start="4"><li>其他方法</li></ol><p>所有节点类型还共享了两个方法。第一个是 <code>cloneNode()</code>，会返回与调用它的节点一模一样的节 点。<code>cloneNode()</code> 方法接收一个布尔值参数，表示是否深复制。在传入 <code>true</code> 参数时，会进行深复制， 即复制节点及其整个子 DOM 树。如果传入 <code>false</code>，则只会复制调用该方法的节点。复制返回的节点属 于文档所有，但尚未指定父节点，所以可称为孤儿节点(orphan)。可以通过 <code>appendChild()</code>、 <code>insertBefore()</code>或 <code>replaceChild()</code>方法把孤儿节点添加到文档中。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>cloneNode()</code> 方法不会复制添加到 DOM 节点的 JavaScript 属性，比如事件处理程 序。这个方法只复制 HTML 属性，以及可选地复制子节点。除此之外则一概不会复制。 IE 在很长时间内会复制事件处理程序，这是一个 bug，所以推荐在复制前先删除事件处 理程序。</p></div><p><code>normalize()</code>。这个方法唯一的任务就是处理文档子树中的文本节 点。由于解析器实现的差异或 DOM 操作等原因，可能会出现并不包含文本的文本节点，或者文本节点之间互为同胞关系。在节点上调用 <code>normalize()</code> 方法会检测这个节点的所有后代，从中搜索上述两种情形。如果发现空文本节点，则将其删除;如果两个同胞节点是相邻的，则将其合并为一个文本节点。 这个方法将在本章后面进一步讨论。</p><h3 id="_14-1-2-document-类型" tabindex="-1">14.1.2 Document 类型 <a class="header-anchor" href="#_14-1-2-document-类型" aria-label="Permalink to &quot;14.1.2 Document 类型&quot;">​</a></h3><p>Document 类型是 JavaScript 中表示文档节点的类型。在浏览器中，文档对象 document 是 HTMLDocument 的实例(HTMLDocument 继承 Document)，表示整个 HTML 页面。document 是 window 对象的属性，因此是一个全局对象。Document 类型的节点有以下特征:</p><ul><li>nodeType 等于 <code>9</code>;</li><li>nodeName 值为 <code>#document</code>;</li><li>nodeValue 值为 <code>null</code>;</li><li>parentNode 值为 <code>null</code>;</li><li>ownerDocument 值为 <code>null</code>;</li><li>子节点可以是 <code>DocumentType</code>(最多一个)、<code>Element</code>(最多一个)、<code>ProcessingInstruction</code> 或 <code>Comment</code> 类型。</li></ul><p>Document 类型可以表示 HTML 页面或其他 XML 文档，但最常用的还是通过 HTMLDocument 的实例取得 <code>document</code> <code>对象。document</code> 对象可用于获取关于页面的信息以及操纵其外观和底层结构。</p><ol><li>文档子节点</li></ol><p>虽然 DOM 规范规定 Document 节点的子节点可以是 <code>DocumentType</code>、<code>Element</code>、<code>Processing-Instruction</code> 或 <code>Comment</code>，但也提供了两个访问子节点的快捷方式。第一个是 <code>documentElement</code> 属 性，始终指向 HTML 页面中的<code>&lt;html&gt;</code>元素。虽然 document.childNodes 中始终有<code>&lt;html&gt;</code>元素，但使用 <code>documentElement</code> 属性可以更快更直接地访问该元素。</p><p>作为 <code>HTMLDocument</code> 的实例，<code>document</code> 对象还有一个 <code>body</code> 属性，直接指向<code>&lt;body&gt;</code>元素。因为 这个元素是开发者使用最多的元素，所以 <code>JavaScript</code> 代码中经常可以看到 <code>document.body</code>。</p><p>所有主流浏览器都支持 <code>document.documentElement</code> 和 <code>document.body</code>。<code>Document</code> 类型另一种可能的子节点是 DocumentType。<code>&lt;!doctype&gt;</code>标签是文档中独立的部分，其信息可以通过 <code>doctype</code> 属性(在浏览器中是 <code>document.doctype</code>)来访问。</p><p>严格来讲出现在<code>&lt;html&gt;</code>元素外面的注释也是文档的子节点，它们的类型是 <code>Comment</code>。不过， 由于浏览器实现不同，这些注释不一定能被识别，或者表现可能不一致。</p><p>一般来说，<code>appendChild()</code>、<code>removeChild()</code>和 <code>replaceChild()</code>方法不会用在 document 对象 上。这是因为文档类型(如果存在)是只读的，而且只能有一个 <code>Element</code> 类型的子节点(即<code>&lt;html&gt;</code>， 已经存在了)。</p><ol start="2"><li>文档信息</li></ol><p><code>document</code> 作为 <code>HTMLDocument</code> 的实例，还有一些标准 <code>Document</code> 对象上所没有的属性。这些属性提供浏览器所加载网页的信息。其中第一个属性是 <code>title</code>，包含<code>&lt;title&gt;</code>元素中的文本，通常显示在浏览器窗口或标签页的标题栏。通过这个属性可以读写页面的标题，修改后的标题也会反映在浏览器标题栏上。</p><p>接下来要介绍的 3 个属性是 <code>URL</code>、<code>domain</code> 和 <code>referrer</code>。</p><p><code>URL</code> 包含当前页面的完整 <code>URL</code>(地址栏中的 URL)，<code>domain</code> 包含页面的域名，而 <code>referrer</code> 包含链接到当前页面的那个页面的 <code>URL</code>。如 果当前页面没有来源，则 <code>referrer</code> 属性包含空字符串。</p><p>因为跨源通信存在安全隐患，所以不同子域的页面间无法通过 <code>JavaScript</code> 通信。此时，在每个页面上把 <code>document.domain</code> 设置为相同的值，这些页面就可以访问对方的 <code>JavaScript</code> 对象了。比如，一个加载自 www.wrox.com 的页面中包含一个内嵌窗格，其中的页面加载自 p2p.wrox.com。这两个页面的 <code>document.domain</code> 包含不同的字符串，内部和外部页面相互之间不能 访问对方的 JavaScript 对象。如果每个页面都把 <code>document.domain</code> 设置为 wrox.com，那这两个页面 之间就可以通信了。</p><p>浏览器对 <code>domain</code> 属性还有一个限制，即这个属性一旦放松就不能再收紧。比如，把 <code>document.domain</code> 设置为&quot;wrox.com&quot;之后，就不能再将其设置回&quot;p2p.wrox.com&quot;，后者会导致错误</p><ol start="3"><li>定位元素</li></ol><p>使用 DOM 最常见的情形可能就是获取某个或某组元素的引用，然后对它们执行某些操作。 document 对象上暴露了一些方法，可以实现这些操作。<code>getElementById()</code>和 <code>getElementsByTagName()</code>就是 <code>Document</code> 类型提供的两个方法。</p><p><code>getElementsByTagName()</code> 这个方法接收一个参数，即要 获取元素的标签名，返回包含零个或多个元素的 <code>NodeList</code>。在 HTML 文档中，这个方法返回一个 <code>HTMLCollection</code> 对象。考虑到二者都是“实时”列表，<code>HTMLCollection</code> 与 <code>NodeList</code> 是很相似的。</p><p>与 <code>NodeList</code> 对象一样，也可以 使用中括号或 <code>item()</code> 方法从 <code>HTMLCollection</code> 取得特定的元素。</p><p><code>HTMLCollection</code> 对象还有一个额外的方法 <code>namedItem()</code>，可通过标签的 name 属性取得某一项的引用。对于 <code>name</code> 属性的元素，还可以直接使用中括号来获取。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> images.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> images.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">namedItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myImage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myImage </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> images[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myImage&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span></code></pre></div><p>对 <code>HTMLCollection</code> 对象而言，中括号既可以接收数值索引，也可以接收字符串索引。而在后台， 数值索引会调用 <code>item()</code>，字符串索引会调用 <code>namedItem()</code></p><p>要取得文档中的所有元素，可以给 <code>getElementsByTagName()</code> 传入<code>*</code>。在 JavaScript 和 CSS 中，<code>*</code> 一般被认为是匹配一切的字符。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allElements </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;*&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>对于<code>document.getElementsByTagName()</code>方法，虽然规范要求区分标签的大小写，但为了最大限度兼容原有 HTML 页面，实际上是不区分大小写的。如果是在 XML 页面(如 XHTML)中使用，那么 <code>document.getElementsByTagName()</code>就是区分大小写的。</p></div><p>HTMLDocument类型上定义的获取元素的第三个方法是<code>document.getElementsByName()</code>。</p><p>一般情况下，还有一个 <code>document.getElementsByClassName()</code></p><ol start="4"><li>特殊集合</li></ol><p>document 对象上还暴露了几个特殊集合，这些集合也都是 HTMLCollection 的实例。这些集合是访问文档中公共部分的快捷方式。</p><ul><li><code>document.anchors</code> 包含文档中所有带 name 属性的<code>&lt;a&gt;</code>元素。</li><li><code>document.applets</code> 包含文档中所有<code>&lt;applet&gt;</code>元素(因为<code>&lt;applet&gt;</code>元素已经不建议使用，所以这个集合已经废弃)。</li><li><code>document.forms</code> 包含文档中所有<code>&lt;form&gt;</code>元素(与 <code>document.getElementsByTagName(&quot;form&quot;)</code> 返回的结果相同)。</li><li><code>document.images</code> 包含文档中所有<code>&lt;img&gt;</code>元素(与 <code>document.getElementsByTagName(&quot;img&quot;)</code> 返回的结果相同)。</li><li><code>document.links</code> 包含文档中所有带 <code>href</code> 属性的<code>&lt;a&gt;</code>元素。</li></ul><p>这些特殊集合始终存在于 HTMLDocument 对象上，而且与所有 HTMLCollection 对象一样，其内容也会实时更新以符合当前文档的内容。</p><ol start="5"><li>DOM 兼容性检测</li></ol><p>由于 DOM 有多个 Level 和多个部分，因此确定浏览器实现了 DOM 的哪些部分是很必要的。 <code>document.implementation</code> 属性是一个对象，其中提供了与浏览器 DOM 实现相关的信息和能力。DOM Level 1在<code>document.implementation</code>上只定义了一个方法，即<code>hasFeature()</code>。这个方法接收两个参数:特性名称和 DOM 版本。如果浏览器支持指定的特性和版本，则 <code>hasFeature()</code> 方法返回 <code>true</code></p><p>由于实现不一致，因此 <code>hasFeature()</code> 的返回值并不可靠。目前这个方法已经被<code>废弃</code>，不再建议使用。为了向后兼容，目前主流浏览器仍然支持这个方法，但无论检测什么都一律返回 <code>true</code>。</p><ol start="6"><li>文档写入</li></ol><p>document 对象有一个古老的能力，即向网页输出流中写入内容。这个能力对应 4 个方法:<code>write()</code>、<code>writeln()</code>、<code>open()</code>和 <code>close()</code> 。 其中，<code>write()</code>和 <code>writeln()</code>方法都接收一个字符串参数，可以将这个字符串写入网页中。<code>write()</code>简单地写入文本，而 <code>writeln()</code>还会在字符串末尾追加一个换行符 (\n)。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- &quot;&lt;/script&gt;&quot;会匹配最外层的&lt;script&gt;标签，导致页面中 显示出&quot;); --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/javascript&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&lt;script type=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">text/javascript</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> src=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">file.js</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&gt;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&lt;/script&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/javascript&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">write</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&lt;script type=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">text/javascript</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> src=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">file.js</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\&quot;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&gt;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\/</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">script&gt;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>字符串<code>&quot;&lt;\/script&gt;&quot;</code>不会再匹配最外层的<code>&lt;script&gt;</code>标签，因此不会在页面中输出额外内容。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在页面渲染期间通过 <code>document.write()</code> 向文档中输出内容。如果是在页面加 载完之后再调用 <code>document.write()</code>，则输出的内容会重写整个页面</p></div><p><code>open()</code> 和 <code>close()</code> 方法分别用于打开和关闭网页输出流。在调用 <code>write()</code> 和 <code>writeln()</code> 时，这两个方法都不是必需的。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>严格的XHTML文档不支持文档写入。对于内容类型为 <code>application/xml+xhtml</code> 的页面，这些方法不起作用。</p></div><h3 id="_14-1-3-element类型" tabindex="-1">14.1.3 Element类型 <a class="header-anchor" href="#_14-1-3-element类型" aria-label="Permalink to &quot;14.1.3 Element类型&quot;">​</a></h3><p>除了 <code>Document</code> 类型，<code>Element</code> 类型就是Web开发中最常用的类型了。<code>Element</code> 表示XML或HTML 元素，对外暴露出访问元素标签名、子节点和属性的能力。<code>Element</code> 类型的节点具有以下特征:</p><ul><li>nodeType 等于 1;</li><li>nodeName 值为元素的标签名;</li><li>nodeValue 值为 null;</li><li>parentNode 值为 Document 或 Element 对象;</li><li>子节点可以是 Element、Text、Comment、ProcessingInstruction、CDATASection、EntityReference 类型。</li></ul><p><code>div.tagName</code> 实际上返回的是&quot;DIV&quot;而不是 &quot;div&quot;。在 HTML 中，元素标签名始终以全大写表示;在 XML(包括 XHTML)中，标签名始终与源代码中的大小写一致。如果不确定脚本是在 HTML 文档还是 XML 文档中运行，最好将标签名转换为小写形式</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (element.tagName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){ </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 不要这样做，可能出错! // do something here</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (element.tagName.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLowerCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){ </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 推荐，适用于所有文档 // 做点什么</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol><li>HTML元素</li></ol><p>所有 HTML 元素都通过 HTMLElement 类型表示，包括其直接实例和间接实例。另外，HTMLElement 直接继承 Element 并增加了一些属性。</p><ul><li>id，元素在文档中的唯一标识符;</li><li>title，包含元素的额外信息，通常以提示条形式展示;</li><li>lang，元素内容的语言代码(很少用);</li><li>dir，语言的书写方向(&quot;ltr&quot;表示从左到右，&quot;rtl&quot;表示从右到左，同样很少用);</li><li>className，相当于 class 属性，用于指定元素的 CSS 类(因为 class 是 ECMAScript 关键字，所以不能直接用这个名字)。</li></ul><p>所有这些都可以用来获取对应的属性值，也可以用来修改相应的值。</p><p>并非所有这些属性的修改都会对页面产生影响。比如，把 id 或 lang 改成其他值对用户是不可见的(假设没有基于这两个属性应用 CSS 样式)，而修改 title 属性则只会在鼠标移到这个元素上时才会反映出来。修改 dir 会导致页面文本立即向左或向右对齐。修改 className 会立即反映应用到新类名的 CSS 样式(如果定义了不同的样式)。</p><ol start="2"><li>取得属性</li></ol><p>每个元素都有零个或多个属性，通常用于为元素或其内容附加更多信息。与属性相关的 DOM 方法主要有 3 个: <code>getAttribute()</code>、<code>setAttribute()</code> 和 <code>removeAttribute()</code>。这些方法主要用于操纵属性，包括在 HTMLElement 类型上定义的属性。</p><p>getAttribute()方法也能取得不是 HTML 语言正式属性的自定义属性的值。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myDiv&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> my_special_attribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;my_special_attribute&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>注意，属性名不区分大小写，因此&quot;ID&quot;和&quot;id&quot;被认为是同一个属性。另外，根据 HTML5 规范的 要求，自定义属性名应该前缀 <code>data-</code> 以方便验证。</p></div><p>通过 DOM 对象访问的属性中有两个返回的值跟使用 getAttribute()取得的值不一样。首先是 style 属性，这个属性用于为元素设定 CSS 样式。在使用 getAttribute()访问 style 属性时，返回的 是 CSS 字符串。而在通过 DOM 对象的属性访问时，style 属性返回的是一个(CSSStyleDeclaration) 7 对象。DOM 对象的 style 属性用于以编程方式读写元素样式，因此不会直接映射为元素中 style 属 性的字符串值。</p><p>第二个属性其实是一类，即事件处理程序(或者事件属性)，比如 onclick。在元素上使用事件属 性时(比如 onclick)，属性的值是一段 JavaScript 代码。如果使用 getAttribute()访问事件属性， 则返回的是字符串形式的源代码。而通过 DOM 对象的属性访问事件属性时返回的则是一个 JavaScript 函数(未指定该属性则返回 null)。这是因为 onclick 及其他事件属性是可以接受函数作为值的。</p><p>考虑到以上差异，开发者在进行 DOM 编程时通常会放弃使用 <code>getAttribute()</code> 而只使用对象属性。 <code>getAttribute()</code> 主要用于取得自定义属性的值。</p><ol start="3"><li>设置属性</li></ol><p>与 <code>getAttribute()</code> 配套的方法是 <code>setAttribute()</code>，这个方法接收两个参数:要设置的属性名和属性的值。如果属性已经存在，则 <code>setAttribute()</code> 会以指定的值替换原来的值;如果属性不存在，则 <code>setAttribute()</code> 会以指定的值创建该属性。</p><p><code>setAttribute()</code> 适用于 HTML 属性，也适用于自定义属性。另外，使用 <code>setAttribute()</code> 方法<strong>设置的属性名会规范为小写形式</strong>，因此&quot;ID&quot;会变成&quot;id&quot;。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;someOtherId&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;class&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;ft&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>因为元素属性也是 DOM 对象属性，所以直接给 DOM 对象的属性赋值也可以设置元素属性的值，</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;someOtherId&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.align </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;left&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>最后一个方法<code> removeAttribute()</code> 用于从元素中删除属性。这样不单单是清除属性的值，而是会把整个属性完全从元素中去掉。</p><ol start="4"><li>attributes 属性</li></ol><p><code>Element</code> 类型是唯一使用 <code>attributes</code> 属性的 DOM 节点类型。<code>attributes</code> 属性包含一个 <code>NamedNodeMap</code> 实例，是一个类似 <code>NodeList</code> 的“实时”集合。元素的每个属性都表示为一个 <code>Attr</code> 节 点，并保存在这个 <code>NamedNodeMap</code> 对象中。</p><ul><li>getNamedItem(name)，返回 nodeName 属性等于 name 的节点;</li><li>removeNamedItem(name)，删除 nodeName 属性等于 name 的节点;</li><li>setNamedItem(node)，向列表中添加 node 节点，以其 nodeName 为索引;</li><li>item(pos)，返回索引位置 pos 处的节点。</li></ul><p><code>attributes</code> 属性中的每个节点的 <code>nodeName</code> 是对应属性的名字，<code>nodeValue</code> 是属性的值。比如， 要取得元素 id 属性的值，可以使用以下代码:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.attributes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getNamedItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).nodeValue;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.attributes[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].nodeValue;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 实测 chrome 中还可以使用</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> idObject </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.attributes.id</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> idObject.name</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> idObject.value</span></span></code></pre></div><p>同样，也可以用这种语法设置属性的值，即先取得属性节点，再将其 nodeValue 设置为新值。</p><p><code>removeNamedItem()</code> 方法与元素上的 <code>removeAttribute()</code> 方法类似，也是删除指定名字的属性。 下面的例子展示了这两个方法唯一的不同之处，就是 <code>removeNamedItem()</code>返回表示被删除属性的 <code>Attr</code> 节点。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldAttr </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.attributes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeNamedItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// id=xxx</span></span></code></pre></div><p><code>setNamedItem()</code>方法很少使用，它接收一个属性节点，然后给元素添加一个新属性</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">element.attributes.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setNamedItem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newAttr);</span></span></code></pre></div><p>一般来说，因为使用起来更简便，通常开发者更喜欢使用 <code>getAttribute()</code>、<code>removeAttribute()</code> 和 <code>setAttribute()</code> 方法，而不是刚刚介绍的 <code>NamedNodeMap</code> 对象的方法。</p><p><code>attributes</code> 属性最有用的场景是需要迭代元素上所有属性的时候。这时候往往是要把 DOM 结构 序列化为 XML 或 HTML 字符串。比如，以下代码能够迭代一个元素上的所有属性并以 <code>attribute1= &quot;value1&quot; attribute2=&quot;value2&quot;</code>的形式生成格式化字符串:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> outputAttributes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pairs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.attributes.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i) { </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> attribute</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.attributes[i]; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pairs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">attribute</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nodeName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}=&quot;${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">attribute</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nodeValue</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}&quot;`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pairs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot; &quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个函数使用数组存储每个名/值对，迭代完所有属性后，再将这些名/值对用空格拼接在一起。(这个技术常用于序列化为长字符串。)这个函数中的 for 循环使用 <code>attributes.length</code> 属性迭代每个属性，将每个属性的名字和值输出为字符串。不同浏览器返回的 <code>attributes</code> 中的属性顺序也可能不一样。HTML 或 XML 代码中属性出现的顺序不一定与 <code>attributes</code> 中的顺序一致。</p><ol start="5"><li>创建元素</li></ol><p>可以使用 <code>document.createElement()</code> 方法创建新元素。这个方法接收一个参数，即要创建元素的标签名。在 HTML 文档中，标签名是不区分大小写的，而 XML 文档(包括 XHTML)是区分大小写的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>使用 <code>createElement()</code> 方法创建新元素的同时也会将其 <code>ownerDocument</code> 属性设置为 <code>document</code>。 此时，可以再为其添加属性、添加更多子元素。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;myNewDiv&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;box&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>在新元素上设置这些属性只会附加信息。因为这个元素还没有添加到文档树，所以不会影响浏览器显示。要把元素添加到文档树，可以使用 <code>appendChild()</code>、<code>insertBefore()</code>或 <code>replaceChild()</code>。 比如，以下代码会把刚才创建的元素添加到文档的<code>&lt;body&gt;</code>元素中</p><ol start="6"><li>元素后代</li></ol><p>元素可以拥有任意多个子元素和后代元素，因为元素本身也可以是其他元素的子元素。<code>childNodes</code> 属性包含元素所有的子节点，这些子节点可能是其他元素、文本节点、注释或处理指令。不同浏览器在识别这些节点时的表现有明显不同。</p><p>要取得某个元素的子节点和其他后代节点，可以使用元素的 <code>getElementsByTagName()</code> 方法。在 元素上调用这个方法与在文档上调用是一样的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ul </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myList&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> items </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ul.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;li&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><h3 id="_14-1-4-text-元素" tabindex="-1">14.1.4 Text 元素 <a class="header-anchor" href="#_14-1-4-text-元素" aria-label="Permalink to &quot;14.1.4 Text 元素&quot;">​</a></h3><p>Text 节点由 Text 类型表示，包含按字面解释的纯文本，也可能包含转义后的 HTML 字符，但不含 HTML 代码。Text 类型的节点具有以下特征:</p><ul><li>nodeType 等于 3;</li><li>nodeName 值为&quot;#text&quot;;</li><li>nodeValue 值为节点中包含的文本;</li><li>parentNode 值为 Element 对象;</li><li>不支持子节点。</li></ul><p>Text 节点中包含的文本可以通过 nodeValue 属性访问，也可以通过 data 属性访问，这两个属性包含相同的值。修改 nodeValue 或 data 的值，也会在另一个属性反映出来。文本节点暴露了以下操作文本的方法:</p><ul><li>appendData(text)，向节点末尾添加文本 text;</li><li>deleteData(offset, count)，从位置 offset 开始删除 count 个字符;</li><li>insertData(offset, text)，在位置 offset 插入 text;</li><li>replaceData(offset, count, text)，用 text 替换从位置 offset 到 offset + count 的文本;</li><li>splitText(offset)，在位置 offset 将当前文本节点拆分为两个文本节点;</li><li>substringData(offset, count)，提取从位置 offset 到 offset + count 的文本。</li></ul><p>除了这些方法，还可以通过 <code>length</code> 属性获取文本节点中包含的字符数量。这个值等于 <code>nodeValue.length</code> 和 <code>data.length</code>。</p><p>默认情况下，包含文本内容的每个元素最多只能有一个文本节点。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 没有内容，因此没有文本节点 --&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 有空格，因此有一个文本节点 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 有内容，因此有一个文本节点 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Hello World!&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>示例中的第一个<code>&lt;div&gt;</code>元素中不包含内容，因此不会产生文本节点。只要开始标签和结束标签之间有内容，就会创建一个文本节点，因此第二个<code>&lt;div&gt;</code>元素会有一个文本节点的子节点，虽然它只包含空格。这个文本节点的 nodeValue 就是一个空格。第三个<code>&lt;div&gt;</code>元素也有一个文本节点的子节点，其 nodeValue 的值为&quot;Hello World!&quot;。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> textNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div.firstChild; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或div.childNodes[0]</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 取得文本节点的引用后，可以像这样来修改它</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.firstChild.nodeValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Some other message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>只要节点在当前的文档树中，这样的修改就会马上反映出来。修改文本节点还有一点要注意，就是 HTML 或 XML 代码(取决于文档类型)会被转换成实体编码，即小于号、大于号或引号会被转义</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出为&quot;Some &amp;lt;strong&amp;gt;other&amp;lt;/strong&amp;gt; message&quot; </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">div.firstChild.nodeValue </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Some &lt;strong&gt;other&lt;/strong&gt; message&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p>这实际上是在将 HTML 字符串插入 DOM 文档前进行编码的有效方式。</p><ol><li>创建文本节点</li></ol><p><code>document.createTextNode()</code> 可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。 跟设置已有文本节点的值一样，这些要插入的文本也会应用 HTML 或 XML 编码</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> textNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTextNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;&lt;strong&gt;Hello&lt;/strong&gt; world!&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>创建新文本节点后，其 <code>ownerDocument</code> 属性会被设置为 <code>document</code>。但在把这个节点添加到文档树之前，我们不会在浏览器中看到它。</p><p>一般来说一个元素只包含一个文本子节点。不过，也可以让元素包含多个文本子节点。在将一个文本节点作为另一个文本节点的同胞插入后，两个文本节点的文本之间不会包含空格。</p><ol start="2"><li>规范化文本节点</li></ol><p>DOM 文档中的同胞文本节点可能导致困惑，因为一个文本节点足以表示一个文本字符串。同样， DOM 文档中也经常会出现两个相邻文本节点。为此，有一个方法可以合并相邻的文本节点。这个方法叫 <code>normalize()</code>，是在 Node 类型中定义的(因此所有类型的节点上都有这个方法)。在包含两个或多 个相邻文本节点的父节点上调用 <code>normalize()</code>时，所有同胞文本节点会被合并为一个文本节点，这个文本节点的 <code>nodeValue</code> 就等于之前所有同胞节点 <code>nodeValue</code> 拼接在一起得到的字符串。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>浏览器在解析文档时，永远不会创建同胞文本节点。同胞文本节点只会出现在 DOM 脚本生成的文档树中。</p></div><ol start="3"><li>拆分文本节点</li></ol><p>Text 类型定义了一个与 <code>normalize()</code> 相反的方法——<code>splitText()</code>。这个方法可以在指定的偏移位置拆分 <code>nodeValue</code>，将一个文本节点拆分成两个文本节点。拆分之后，原来的文本节点包含开头到偏移位置前的文本，新文本节点包含剩下的文本。这个方法返回新的文本节点，具有与原来的文本节点相同的 <code>parentNode</code>。</p><h3 id="_14-1-5-comment类型" tabindex="-1">14.1.5 Comment类型 <a class="header-anchor" href="#_14-1-5-comment类型" aria-label="Permalink to &quot;14.1.5 Comment类型&quot;">​</a></h3><p>DOM 中的注释通过 Comment 类型表示。Comment 类型的节点具有以下特征:</p><ul><li>nodeType 等于 <code>8</code>;</li><li>nodeName 值为 <code>#comment</code>;</li><li>nodeValue 值为注释的内容;</li><li>parentNode 值为 <code>Document</code> 或 <code>Element</code> 对象;</li><li>不支持子节点。</li></ul><p>Comment 类型与 Text 类型继承同一个基类(CharacterData)，因此拥有除 splitText() 之外 Text 节点所有的字符串操作方法。与 Text 类型相似，注释的实际内容可以通过 nodeValue 或 data 属性获得。</p><p>注释节点可以作为父节点的子节点来访问。</p><p>可以使用 <code>document.createComment()</code> 方法创建注释节点，参数为注释文本。</p><p>显然，注释节点很少通过 JavaScrpit 创建和访问，因为注释几乎不涉及算法逻辑。此外，浏览器不承认结束的<code>&lt;/html&gt;</code>标签之后的注释。如果要访问注释节点，则必须确定它们是<code>&lt;html&gt;</code>元素的后代。</p><h3 id="_14-1-6-cdatasection-类型" tabindex="-1">14.1.6 CDATASection 类型 <a class="header-anchor" href="#_14-1-6-cdatasection-类型" aria-label="Permalink to &quot;14.1.6 CDATASection 类型&quot;">​</a></h3><p>CDATASection 类型表示 XML 中特有的 CDATA 区块。CDATASection 类型继承 Text 类型，因此拥有包括 splitText()在内的所有字符串操作方法。CDATASection 类型的节点具有以下特征:</p><ul><li>nodeType 等于 4;</li><li>nodeName 值为 <code>#cdata-section</code>;</li><li>nodeValue 值为 CDATA 区块的内容;</li><li>parentNode 值为 Document 或 Element 对象;</li><li>不支持子节点。</li></ul><h3 id="_14-1-7-documenttype-类型" tabindex="-1">14.1.7 DocumentType 类型 <a class="header-anchor" href="#_14-1-7-documenttype-类型" aria-label="Permalink to &quot;14.1.7 DocumentType 类型&quot;">​</a></h3><p>DocumentType 类型的节点包含文档的文档类型(doctype)信息，具有以下特征:</p><ul><li>nodeType 等于 10;</li><li>nodeName 值为文档类型的名称;</li><li>nodeValue 值为 null;</li><li>parentNode 值为 Document 对象;</li><li>不支持子节点。</li></ul><p>DocumentType 对象在 DOM Level 1 中不支持动态创建，只能在解析文档代码时创建。对于支持这个类型的浏览器，DocumentType 对象保存在 document.doctype 属性中。DOM Level 1 规定了 DocumentType 对象的 3 个属性:name、entities 和 notations。其中，name 是文档类型的名称， entities 是这个文档类型描述的实体的 NamedNodeMap，而 notations 是这个文档类型描述的表示法的 NamedNodeMap。因为浏览器中的文档通常是 HTML 或 XHTML 文档类型，所以 entities 和 notations 列表为空。(这个对象只包含行内声明的文档类型。)无论如何，只有 name 属性是有用的。 这个属性包含文档类型的名称，即紧跟在<code>&lt;!DOCTYPE</code> 后面的那串文本。</p><h3 id="_14-1-8-documentfragment-类型" tabindex="-1">14.1.8 DocumentFragment 类型 <a class="header-anchor" href="#_14-1-8-documentfragment-类型" aria-label="Permalink to &quot;14.1.8 DocumentFragment 类型&quot;">​</a></h3><p>所有节点类型中，DocumentFragment 类型是唯一一个在标记中没有对应表示的类型。DOM 将 文档片段定义为“轻量级”文档，能够包含和操作节点，却没有完整文档那样额外的消耗。 DocumentFragment 节点具有以下特征:</p><ul><li>nodeType 等于 11;</li><li>nodeName 值为&quot;#document-fragment&quot;;</li><li>nodeValue 值为 null;</li><li>parentNode 值为 null;</li><li>子节点可以是 Element、ProcessingInstruction、Comment、Text、CDATASection 或 EntityReference。</li></ul><p>不能直接把文档片段添加到文档。相反，文档片段的作用是充当其他要被添加到文档的节点的仓库。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fragment </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createDocumentFragment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ul </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myList&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i) { </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> li </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;li&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  li.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTextNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`Item ${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  fragment.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(li);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ul.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(fragment);</span></span></code></pre></div><h3 id="_14-1-9-attr-类型" tabindex="-1">14.1.9 Attr 类型 <a class="header-anchor" href="#_14-1-9-attr-类型" aria-label="Permalink to &quot;14.1.9 Attr 类型&quot;">​</a></h3><p>元素数据在 DOM 中通过 Attr 类型表示。Attr 类型构造函数和原型在所有浏览器中都可以直接访问。技术上讲，属性是存在于元素 attributes 属性中的节点。Attr 节点具有以下特征:</p><ul><li>nodeType 等于 2;</li><li>nodeName 值为属性名;</li><li>nodeValue 值为属性值;</li><li>parentNode 值为 null;</li><li>在 HTML 中不支持子节点;</li><li>在 XML 中子节点可以是 Text 或 EntityReference。</li></ul><p>属性节点尽管是节点，却不被认为是 DOM 文档树的一部分。Attr 节点很少直接被引用，通常开发者更喜欢使用 getAttribute()、removeAttribute()和 setAttribute()方法操作属性。</p><p>Attr 对象上有 3 个属性:name、value 和 specified。其中，name 包含属性名(与 nodeName 一样)，value 包含属性值(与 nodeValue 一样)，而 specified 是一个布尔值，表示属性使用的是默认值还是被指定的值。</p><p>可以使用 document.createAttribute()方法创建新的 Attr 节点，参数为属性名。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>将属性作为节点来访问多数情况下并无必要。推荐使用 <code>getAttribute()</code>、 <code>removeAttribute()</code> 和 <code>setAttribute()</code> 方法操作属性，而不是直接操作属性节点。</p></div><h2 id="_14-2-dom-编程" tabindex="-1">14.2 DOM 编程 <a class="header-anchor" href="#_14-2-dom-编程" aria-label="Permalink to &quot;14.2 DOM 编程&quot;">​</a></h2><p>很多时候，操作 DOM 是很直观的。通过 HTML 代码能实现的，也一样能通过 JavaScript 实现。但有时候，DOM 也没有看起来那么简单。浏览器能力的参差不齐和各种问题，也会导致 DOM 的某些方面会复杂一些。</p><h3 id="_14-2-1-动态脚本" tabindex="-1">14.2.1 动态脚本 <a class="header-anchor" href="#_14-2-1-动态脚本" aria-label="Permalink to &quot;14.2.1 动态脚本&quot;">​</a></h3><p><code>&lt;script&gt;</code>元素用于向网页中插入 JavaScript 代码，可以是 src 属性包含的外部文件，也可以是作为该元素内容的源代码。动态脚本就是在页面初始加载时不存在，之后又通过 DOM 包含的脚本。与对应的 HTML 元素一样，有两种方式通过<code>&lt;script&gt;</code>动态为网页添加脚本:引入外部文件和直接插入源代码。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadScript</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> script </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  script.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> url;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(script);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> script </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">script.text </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;function sayHi(){alert(&#39;hi&#39;);}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(script);</span></span></code></pre></div><h3 id="_14-2-2-动态样式" tabindex="-1">14.2.2 动态样式 <a class="header-anchor" href="#_14-2-2-动态样式" aria-label="Permalink to &quot;14.2.2 动态样式&quot;">​</a></h3><p>CSS样式在HTML页面中可以通过两个元素加载。<code>&lt;link&gt;</code>元素用于包含CSS外部文件，而 <code>&lt;style&gt;</code> 元素用于添加嵌入样式。与动态脚本类似，动态样式也是页面初始加载时并不存在，而是在之后才添加到页面中的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> loadStyles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // link</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> link </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;link&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  link.rel </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;stylesheet&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  link.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;text/css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  link.href </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> url;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;head&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  head.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(link);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // style </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> style </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;style&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> style.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;text/css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    style.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createTextNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(css));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (ex){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // IE</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    style.styleSheet.cssText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> css;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;head&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  head.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(style);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_14-2-3-操作表格" tabindex="-1">14.2.3 操作表格 <a class="header-anchor" href="#_14-2-3-操作表格" aria-label="Permalink to &quot;14.2.3 操作表格&quot;">​</a></h3><p>表格是 HTML 中最复杂的结构之一。通过 DOM 编程创建<code>&lt;table&gt;</code>元素，通常要涉及大量标签，包 括表行、表元、表题，等等。</p><p>为了方便创建表格，HTML DOM 给<code>&lt;table&gt;</code>、<code>&lt;tbody&gt;</code>和 <code>&lt;tr&gt;</code> 元素添加了一些属性和方法。</p><p><code>&lt;table&gt;</code>元素添加了以下属性和方法:</p><ul><li>caption，指向<code>&lt;caption&gt;</code>元素的指针(如果存在);</li><li>tBodies，包含<code>&lt;tbody&gt;</code>元素的 HTMLCollection;</li><li>tFoot，指向<code>&lt;tfoot&gt;</code>元素(如果存在);</li><li>tHead，指向<code>&lt;thead&gt;</code>元素(如果存在);</li><li>rows，包含表示所有行的 HTMLCollection;</li><li>createTHead()，创建<code>&lt;thead&gt;</code>元素，放到表格中，返回引用;</li><li>createTFoot()，创建<code>&lt;tfoot&gt;</code>元素，放到表格中，返回引用;</li><li>createCaption()，创建<code>&lt;caption&gt;</code>元素，放到表格中，返回引用;</li><li>deleteTHead()，删除<code>&lt;thead&gt;</code>元素;</li><li>deleteTFoot()，删除<code>&lt;tfoot&gt;</code>元素;</li><li>deleteCaption()，删除<code>&lt;caption&gt;</code>元素;</li><li>deleteRow(pos)，删除给定位置的行;</li><li>insertRow(pos)，在行集合中给定位置插入一行。</li></ul><p><code>&lt;tbody&gt;</code>元素添加了以下属性和方法:</p><ul><li>rows，包含<code>&lt;tbody&gt;</code>元素中所有行的 HTMLCollection;</li><li>deleteRow(pos)，删除给定位置的行;</li><li>insertRow(pos)，在行集合中给定位置插入一行，返回该行的引用。</li></ul><p><code>&lt;tr&gt;</code>元素添加了以下属性和方法:</p><ul><li>cells，包含<code>&lt;tr&gt;</code>元素所有表元的 HTMLCollection;</li><li>deleteCell(pos)，删除给定位置的表元;</li><li>insertCell(pos)，在表元集合给定位置插入一个表元，返回该表元的引用。</li></ul><h3 id="_14-2-4-使用nodelist" tabindex="-1">14.2.4 使用NodeList <a class="header-anchor" href="#_14-2-4-使用nodelist" aria-label="Permalink to &quot;14.2.4 使用NodeList&quot;">​</a></h3><p>理解 NodeList 对象和相关的 <code>NamedNodeMap</code>、<code>HTMLCollection</code>，是理解 DOM 编程的关键。这 3 个集合类型都是“实时的”，意味着文档结构的变化会实时地在它们身上反映出来，因此它们的值始终代表最新的状态。实际上，NodeList 就是基于 DOM 文档的实时查询。</p><p>下面的代码会导致无穷循环:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> divs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> divs.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(div);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newDiv </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newDiv);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>任何时候要迭代 NodeList，最好再初始化一个变量保存当时查询时的长度，然后用循环变量与这个变量进行比较</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> divs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, len </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> divs.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(div);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在这个例子中，又初始化了一个保存集合长度的变量 len。因为 len 保存着循环开始时集合的长度， 而这个值不会随集合增大动态增长，所以就可以避免前面例子中出现的无穷循环。</span></span></code></pre></div><p>另外，如果不想再初始化一个变量，也可以像下面这样反向迭代集合:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> divs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> divs.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> div </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;div&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(div);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>一般来说，最好限制操作 NodeList 的次数。因为每次查询都会搜索整个文档，所以最好把查询到 的 NodeList 缓存起来。</p><h2 id="_14-3-mutationobserver-接口" tabindex="-1">14.3 MutationObserver 接口 <a class="header-anchor" href="#_14-3-mutationobserver-接口" aria-label="Permalink to &quot;14.3 MutationObserver 接口&quot;">​</a></h2><p>添加到 DOM 规范中的 MutationObserver 接口，可以在 DOM 被修改时异步执行回调。使用 MutationObserver 可以观察整个文档、DOM 树的一部分，或某个元素。此外还可以观察元素属性、子节点、文本，或者前三者任意组合的变化。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>新引进 <code>MutationObserver</code> 接口是为了取代废弃的 <code>MutationEvent</code> 。</p></div><h3 id="_14-3-1-基本用法" tabindex="-1">14.3.1 基本用法 <a class="header-anchor" href="#_14-3-1-基本用法" aria-label="Permalink to &quot;14.3.1 基本用法&quot;">​</a></h3><p><code>MutationObserver</code> 的实例要通过调用 <code>MutationObserver</code> 构造函数并传入一个回调函数来创建:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;DOM was mutated!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span></code></pre></div><ol><li>observe() 方法</li></ol><p>新创建的 <code>MutationObserver</code> 实例不会关联 DOM 的任何部分。要把这个 <code>observer</code> 与 DOM 关 联起来，需要使用 <code>observe()</code> 方法。这个方法接收两个必需的参数:要观察其变化的 DOM 节点，以及 一个 <code>MutationObserverInit</code> 对象。</p><p><code>MutationObserverInit</code> 对象用于控制观察哪些方面的变化，是一个键/值对形式配置选项的字典。 例如，下面的代码会创建一个观察者(observer)并配置它观察<code>&lt;body&gt;</code>元素上的属性变化:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&lt;body&gt; attributes changed&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body, { attributes: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><p>执行以上代码后，<code>&lt;body&gt;</code>元素上任何属性发生变化都会被这个 <code>MutationObserver</code> 实例发现，然后就会异步执行注册的回调函数。<code>&lt;body&gt;</code>元素后代的修改或其他非属性修改都不会触发回调进入任务队列。</p><ol start="2"><li>回调与 <code>MutationRecord</code></li></ol><p>每个回调都会收到一个 <code>MutationRecord</code> 实例的数组。<code>MutationRecord</code> 实例包含的信息包括发生了什么变化，以及 DOM 的哪一部分受到了影响。因为回调执行之前可能同时发生多个满足观察条件的事件，所以每次执行回调都会传入一个包含按顺序入队的 <code>MutationRecord</code> 实例的数组。</p><p>连续修改会生成多个 <code>MutationRecord</code> 实例，下次回调执行时就会收到包含所有这些实例的数组， 顺序为变化事件发生的顺序。</p><p><code>MutationRecord</code> 实例的属性。</p><ul><li>target 被修改影响的目标节点</li><li>type 字符串，表示变化的类型:&quot;attributes&quot;、&quot;characterData&quot;或&quot;childList&quot;</li><li>oldValue 如果在 MutationObserverInit 对象中启用(attributeOldValue 或 characterData OldValue 为 true)，&quot;attributes&quot;或&quot;characterData&quot;的变化事件会设置这个属性为被替代的值 &quot;childList&quot; 类型的变化始终将这个属性设置为 null</li><li>attributeName 对于&quot;attributes&quot;类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为 null</li><li>attributeNamespace 对于使用了命名空间的&quot;attributes&quot;类型的变化，这里保存被修改属性的名字 其他变化事件会将这个属性设置为 null</li><li>addedNodes 对于&quot;childList&quot;类型的变化，返回包含变化中添加节点的 NodeList 默认为空 NodeList</li><li>removedNodes 对于&quot;childList&quot;类型的变化，返回包含变化中删除节点的 NodeList 默认为空 NodeList</li><li>previousSibling 对于&quot;childList&quot;类型的变化，返回变化节点的前一个同胞 Node 默认为 null</li><li>nextSibling 对于&quot;childList&quot;类型的变化，返回变化节点的后一个同胞 Node 默认为 null</li></ul><p>传给回调函数的第二个参数是观察变化的 <code>MutationObserver</code> 的实例</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutationRecords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutationRecords, mutationObserver));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body, { attributes: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span></code></pre></div><ol start="3"><li>disconnect() 方法</li></ol><p>默认情况下，只要被观察的元素不被垃圾回收，MutationObserver 的回调就会响应 DOM 变化事 件，从而被执行。要提前终止执行回调，可以调用 disconnect() 方法。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&lt;body&gt; attributes changed&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body, { attributes: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disconnect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//(没有日志输出)</span></span></code></pre></div><p>要想让已经加入任务队列的回调执行，可以使用 setTimeout()让已经入列的回调执行完毕再调用 disconnect()</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&lt;body&gt; attributes changed&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body, { attributes: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">disconnect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.body.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;bar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &lt;body&gt; attributes changed</span></span></code></pre></div><ol start="4"><li>复用 <code>MutationObserver</code></li></ol><p>多次调用 <code>observe()</code> 方法，可以复用一个 <code>MutationObserver</code> 对象观察多个不同的目标节点。此时，<code>MutationRecord</code> 的 <code>target</code> 属性可以标识发生变化事件的目标节点。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutationRecords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutationRecords.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x.target)));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 向页面主体添加两个子节点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> childA </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    childB </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;span&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(childA);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(childB);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 观察两个子节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(childA, { attributes: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(childB, { attributes: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> });</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改两个子节点的属性 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">childA.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">childB.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&lt;div&gt;, &lt;span&gt;]</span></span></code></pre></div><p><code>disconnect()</code> 方法是一个“一刀切”的方案，调用它会停止观察所有目标。</p><ol start="5"><li>重用 <code>MutationObserver</code></li></ol><p>调用 <code>disconnect()</code> 并不会结束 <code>MutationObserver</code> 的生命。还可以重新使用这个观察者，再将它关联到新的目标节点。</p><h3 id="_14-3-2-mutationobserverinit-与观察范围" tabindex="-1">14.3.2 MutationObserverInit 与观察范围 <a class="header-anchor" href="#_14-3-2-mutationobserverinit-与观察范围" aria-label="Permalink to &quot;14.3.2 MutationObserverInit 与观察范围&quot;">​</a></h3><p><code>MutationObserverInit</code> 对象用于控制对目标节点的观察范围。粗略地讲，观察者可以观察的事件包括属性变化、文本变化和子节点变化。</p><p>下表列出了 <code>MutationObserverInit</code> 对象的属性</p><ul><li>subtree 布尔值，表示除了目标节点，是否观察目标节点的子树(后代)，如果是 <code>false</code>，则只观察目标节点的变化;如果是 <code>true</code>，则观察目标节点及其整个子树，默认为 <code>false</code></li><li>attributes 布尔值，表示是否观察目标节点的属性变化，默认为 <code>false</code></li><li>attributeFilter 字符串数组，表示要观察哪些属性的变化，把这个值设置为 <code>true</code> 也会将 <code>attributes</code> 的值转换为 <code>true</code>，默认为观察所有属性</li><li>attributeOldValue 布尔值，表示 <code>MutationRecord</code> 是否记录变化之前的属性值，把这个值设置为 <code>true</code> 也会将 <code>attributes</code> 的值转换为 <code>true</code>，默认为 <code>false</code></li><li>characterData 布尔值，表示修改字符数据是否触发变化事件，默认为 <code>false</code></li><li>characterDataOldValue 布尔值，表示 <code>MutationRecord</code> 是否记录变化之前的字符数据，把这个值设置为 <code>true</code> 也会将 <code>characterData</code> 的值转换为 <code>true</code>，默认为 <code>false</code></li><li>childList 布尔值，表示修改目标节点的子节点是否触发变化事件，默认为 <code>false</code></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在调用<code>observe()</code>时，<code>MutationObserverInit</code>对象中的<code>attribute</code>、<code>characterData</code> 和<code>childList</code>属性必须至少有一项为<code>true</code>(无论是直接设置这几个属性，还是通过设置 <code>attributeOldValue</code> 等属性间接导致它们的值转换为 <code>true</code>)。否则会抛出错误，因为没有任何变化事件可能触发回调。</p></div><ol><li>观察属性</li></ol><p><code>MutationObserver</code> 可以观察节点属性的添加、移除和修改。要为属性变化注册回调，需要在 <code>MutationObserverInit</code> 对象中将 <code>attributes</code> 属性设置为 <code>true</code></p><p>把 <code>attributes</code> 设置为 <code>true</code> 的默认行为是观察所有属性，但不会在 <code>MutationRecord</code> 对象中记 录原来的属性值。如果想观察某个或某几个属性，可以使用<code>attributeFilter</code> 属性来设置白名单，即一个属性名字符串数组</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> observer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MutationObserver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mutationRecords</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mutationRecords));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">observer.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">observe</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body, { attributeFilter: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] });</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加白名单属性</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bar&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加被排除的属性 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setAttribute</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;baz&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;qux&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 只有 foo 属性的变化被记录了</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [MutationRecord]</span></span></code></pre></div><p>如果想在变化记录中保存属性原来的值，可以将 <code>attributeOldValue</code> 属性设置为 true</p><ol start="2"><li>观察字符数据</li></ol><p><code>MutationObserver</code> 可以观察文本节点(如 Text、Comment 或 ProcessingInstruction 节点)中字符的添加、删除和修改。要为字符数据注册回调，需要在 <code>MutationObserverInit</code> 对象中将 <code>characterData</code> 属性设置为 <code>true</code></p><p>将 <code>characterData</code> 属性设置为 <code>true</code> 的默认行为不会在 <code>MutationRecord</code> 对象中记录原来的字符数据。如果想在变化记录中保存原来的字符数据，可以将 <code>characterDataOldValue</code> 属性设置为 <code>true</code></p><ol start="3"><li>观察子节点</li></ol><p><code>MutationObserver</code> 可以观察目标节点子节点的添加和移除。要观察子节点，需要在 <code>MutationObserverInit</code> 对象中将 <code>childList</code> 属性设置为 <code>true</code>。</p><p>对子节点重新排序(尽管调用一个方法即可实现)会报告两次变化事件，因为从技术上会涉及先移 除和再添加。</p><ol start="4"><li>观察子树</li></ol><p>默认情况下，<code>MutationObserver</code> 将观察的范围限定为一个元素及其子节点的变化。可以把观察的范围扩展到这个元素的子树(所有后代节点)，这需要在 <code>MutationObserverInit</code> 对象中将 <code>subtree</code> 属性设置为 <code>true</code>。</p><p>有意思的是，被观察子树中的节点被移出子树之后仍然能够触发变化事件。这意味着在子树中的节 点离开该子树后，即使严格来讲该节点已经脱离了原来的子树，但它仍然会触发变化事件。</p><h3 id="_14-3-3-异步回调与记录队列" tabindex="-1">14.3.3 异步回调与记录队列 <a class="header-anchor" href="#_14-3-3-异步回调与记录队列" aria-label="Permalink to &quot;14.3.3 异步回调与记录队列&quot;">​</a></h3><p><code>MutationObserver</code> 接口是出于性能考虑而设计的，其核心是异步回调与记录队列模型。为了在 大量变化事件发生时不影响性能，每次变化的信息(由观察者实例决定)会保存在 <code>MutationRecord</code> 实例中，然后添加到记录队列。这个队列对每个 <code>MutationObserver</code> 实例都是唯一的，是所有 DOM 变化事件的有序列表。</p><ol><li>记录队列</li></ol><p>每次 <code>MutationRecord</code> 被添加到 <code>MutationObserver</code> 的记录队列时，仅当之前没有已排期的微任 务回调时(队列中微任务长度为 0)，才会将观察者注册的回调(在初始化 <code>MutationObserver</code> 时传入) 作为微任务调度到任务队列上。这样可以保证记录队列的内容不会被回调处理两次。</p><p>不过在回调的微任务异步执行期间，有可能又会发生更多变化事件。因此被调用的回调会接收到一 个 <code>MutationRecord</code> 实例的数组，顺序为它们进入记录队列的顺序。回调要负责处理这个数组的每一 个实例，因为函数退出之后这些实现就不存在了。回调执行后，这些 <code>MutationRecord</code> 就用不着了， 因此记录队列会被清空，其内容会被丢弃。</p><ol start="2"><li>takeRecords() 方法 调用 <code>MutationObserver</code> 实例的 <code>takeRecords()</code> 方法可以清空记录队列，取出并返回其中的所有 <code>MutationRecord</code> 实例。</li></ol><h3 id="_14-3-4-性能、内存与垃圾回收" tabindex="-1">14.3.4 性能、内存与垃圾回收 <a class="header-anchor" href="#_14-3-4-性能、内存与垃圾回收" aria-label="Permalink to &quot;14.3.4 性能、内存与垃圾回收&quot;">​</a></h3><p>DOM Level 2 规范中描述的 MutationEvent 定义了一组会在各种 DOM 变化时触发的事件。由于浏览器事件的实现机制，这个接口出现了严重的性能问题。因此，DOM Level 3 规定废弃了这些事件。 MutationObserver 接口就是为替代这些事件而设计的更实用、性能更好的方案。</p><p>将变化回调委托给微任务来执行可以保证事件同步触发，同时避免随之而来的混乱。为 MutationObserver 而实现的记录队列，可以保证即使变化事件被爆发式地触发，也不会显著地拖慢浏览器。</p><p>无论如何，使用 MutationObserver 仍然不是没有代价的。因此理解什么时候避免出现这种情况 就很重要了。</p><ol><li>MutationObserver 的引用</li></ol><p>MutationObserver 实例与目标节点之间的引用关系是非对称的。MutationObserver 拥有对要观察的目标节点的弱引用。因为是弱引用，所以不会妨碍垃圾回收程序回收目标节点。</p><p>然而，目标节点却拥有对 MutationObserver 的强引用。如果目标节点从 DOM 中被移除，随后被垃圾回收，则关联的 MutationObserver 也会被垃圾回收。</p><ol start="2"><li>MutationRecord 的引用</li></ol><p>记录队列中的每个 MutationRecord 实例至少包含对已有 DOM 节点的一个引用。如果变化是 childList 类型，则会包含多个节点的引用。记录队列和回调处理的默认行为是耗尽这个队列，处理每个 MutationRecord，然后让它们超出作用域并被垃圾回收。</p><p>有时候可能需要保存某个观察者的完整变化记录。保存这些 MutationRecord 实例，也就会保存它们引用的节点，因而会妨碍这些节点被回收。如果需要尽快地释放内存，建议从每个MutationRecord 中抽取出最有用的信息，然后保存到一个新对象中，最后抛弃 MutationRecord。</p><h2 id="_14-4-小结" tabindex="-1">14.4 小结 <a class="header-anchor" href="#_14-4-小结" aria-label="Permalink to &quot;14.4 小结&quot;">​</a></h2><p>文档对象模型(DOM，Document Object Model)是语言中立的 HTML 和 XML 文档的 API。DOM Level 1 将 HTML 和 XML 文档定义为一个节点的多层级结构，并暴露出 JavaScript 接口以操作文档的底层结构和外观。</p><p>DOM 由一系列节点类型构成，主要包括以下几种。</p><ul><li>Node 是基准节点类型，是文档一个部分的抽象表示，所有其他类型都继承 Node。</li><li>Document 类型表示整个文档，对应树形结构的根节点。在 JavaScript 中，document 对象是 Document 的实例，拥有查询和获取节点的很多方法。</li><li>Element 节点表示文档中所有 HTML 或 XML 元素，可以用来操作它们的内容和属性。</li><li>其他节点类型分别表示文本内容、注释、文档类型、CDATA 区块和文档片段。</li></ul><p>DOM 编程在多数情况下没什么问题，在涉及<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>元素时会有一点兼容性问题。因为这些元素分别包含脚本和样式信息，所以浏览器会将它们与其他元素区别对待。</p><p>要理解 DOM，最关键的一点是知道影响其性能的问题所在。DOM 操作在 JavaScript 代码中是代价比较高的，NodeList 对象尤其需要注意。NodeList 对象是“实时更新”的，这意味着每次访问它都会执行一次新的查询。考虑到这些问题，实践中要尽量减少 DOM 操作的数量。</p><p>MutationObserver 是为代替性能不好的 MutationEvent 而问世的。使用它可以有效精准地监控 DOM 变化，而且 API 也相对简单。</p></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-09de1c0f><!--[--><!--]--><div class="edit-info" data-v-09de1c0f><!----><div class="last-updated" data-v-09de1c0f><p class="VPLastUpdated" data-v-09de1c0f data-v-7e05ebdb>Last updated: <time datetime="2022-06-29T09:00:48.000Z" data-v-7e05ebdb></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter" data-v-5d98c3a5 data-v-e315a0ad><div class="container" data-v-e315a0ad><p class="message" data-v-e315a0ad>Powered by Vitepress</p><p class="copyright" data-v-e315a0ad>Copyright © PYPARA</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"blog_introduction.md\":\"KgjVWHPm\",\"learn_javascript_0-javascript继承机制.md\":\"UMd2FdZo\",\"learn_effective-javascript_chapter3-working-with-functions.md\":\"lWH5vZRC\",\"learn_games101_linear-algebra.md\":\"1db608lV\",\"learn_effective-javascript_chapter1-accustoming-yourself-to-javascript.md\":\"7e5CoyUC\",\"learn_javascript高级程序设计_2-html中的javascript.md\":\"D_DlGwCE\",\"learn_effective-javascript_chapter2-variable-scope.md\":\"CiJSIri2\",\"learn_javascript高级程序设计_16-dom2和dom3.md\":\"ZoFmJAUE\",\"learn_javascript高级程序设计_13-客户端检测.md\":\"CvVn1ozE\",\"index.md\":\"DHJ-tfjV\",\"learn_javascript高级程序设计_1-什么是javascript.md\":\"BkAvRS3R\",\"learn_introduction.md\":\"hErMy9qO\",\"learn_effective-javascript_index.md\":\"CX2N2Mps\",\"learn_javascript_4-变量对象.md\":\"pUDK__ki\",\"notes_css.md\":\"DyEoahRP\",\"learn_effective-javascript_chapter4-objects-and-prototypes.md\":\"BVlnBKnd\",\"blog_译-javascript-the-core-第2版.md\":\"D4GgoT3n\",\"notes_git.md\":\"MsRhe70t\",\"learn_javascript_3-执行上下文栈.md\":\"Cdpk5_UU\",\"learn_javascript_11-bind的模拟实现.md\":\"Co7s0Lsb\",\"learn_javascript高级程序设计_4-变量、作用域与内存.md\":\"BBgU0R75\",\"notes_vue3相对路径部署.md\":\"CioGLUK2\",\"learn_javascript_7-执行上下文.md\":\"Bwp-Lx3F\",\"learn_javascript_13-类数组对象与arguments.md\":\"6bvZ2CnB\",\"learn_javascript高级程序设计_17-事件.md\":\"Cemp66ds\",\"learn_javascript高级程序设计_15-dom扩展.md\":\"DeHGcbC2\",\"learn_javascript高级程序设计_14-dom.md\":\"DObm8Pld\",\"learn_javascript_8-闭包.md\":\"BxETkvQr\",\"notes_javascript.md\":\"BIokBCVt\",\"learn_learn_浏览器渲染原理_浏览器渲染原理.md\":\"DKpi67-k\",\"learn_javascript_10-call和apply的模拟实现.md\":\"CIjaicBp\",\"learn_javascript_12-new的模拟实现.md\":\"BYxG-uFX\",\"learn_learn_浏览器渲染原理_面试题.md\":\"DoSRPfEm\",\"learn_javascript_2-词法作用域和动态作用域.md\":\"u7Sxmf20\",\"learn_javascript_6-this.md\":\"DyGIkv5v\",\"learn_javascript_5-作用域链.md\":\"DgExi5Tx\",\"learn_games101_introduction.md\":\"CgLdIucl\",\"learn_javascript高级程序设计_5-基本引用类型.md\":\"D5HMzSZT\",\"learn_javascript高级程序设计_3-语言基础.md\":\"B2GEQssS\",\"learn_javascript_14-创建对象的多种方式和优缺点.md\":\"Mgd-XHUU\",\"notes_npm.md\":\"Bmk4_HKK\",\"notes_nginx.md\":\"BUaPAZx4\",\"learn_learn_浏览器渲染原理_你不知道的 css 之包含块.md\":\"BnGKhdtj\",\"notes_regexp.md\":\"Di9JQTfe\",\"blog_modularization.md\":\"Ce2Q8oes\",\"notes_pdf.md\":\"C9YtcOlO\",\"learn_javascript_1-原型到原型链.md\":\"C2ENjBRa\",\"notes_wechat-miniprogram.md\":\"D4uRZ-U6\",\"notes_vue.md\":\"Ccu9PVaC\",\"reading_introduction.md\":\"DAMVFUoa\",\"learn_javascript高级程序设计_12-bom.md\":\"DU6e6VE1\",\"learn_learn_事件循环_课件.md\":\"COtooawv\",\"learn_javascript高级程序设计_8-对象、类与面向对象编程.md\":\"BvBrJ1w_\",\"learn_learn_事件循环_事件循环.md\":\"C8szPr3E\",\"learn_javascript高级程序设计_9-代理与反射.md\":\"DSv_4Zl8\",\"notes_shell.md\":\"Cu6lYPeJ\",\"notes_sites.md\":\"DYo9RFv0\",\"notes_others.md\":\"CWe2BS0t\",\"notes_modularization.md\":\"B5bu3Z-U\",\"learn_javascript高级程序设计_10-函数.md\":\"DtSsLdH7\",\"learn_javascript高级程序设计_index.md\":\"COZVgrry\",\"learn_javascript高级程序设计_11-期约与异步函数.md\":\"uA8pMjqo\",\"learn_learn_浏览器渲染原理_css 属性计算过程.md\":\"4yG-zYNm\",\"learn_javascript高级程序设计_7-迭代器与生成器.md\":\"WMzKiP3T\",\"learn_javascript高级程序设计_6-集合引用类型.md\":\"-Ptt9Lq4\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"PYPARA\",\"description\":\"个人记录\",\"base\":\"/notes/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"footer\":{\"message\":\"Powered by Vitepress\",\"copyright\":\"Copyright © PYPARA\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/PYPARA\"}],\"nav\":[{\"text\":\"Learn\",\"link\":\"/learn/introduction\",\"activeMatch\":\"/learn/\"},{\"text\":\"Reading\",\"link\":\"/reading/introduction\",\"activeMatch\":\"/reading/\"},{\"text\":\"Blog\",\"link\":\"/blog/introduction\",\"activeMatch\":\"/blog/\"},{\"text\":\"Notes\",\"link\":\"/notes/sites\",\"activeMatch\":\"/notes/\"}],\"sidebar\":{\"/blog/\":[{\"text\":\"Blog\",\"link\":\"/blog/\",\"items\":[{\"text\":\"[译]JavaScript. The Core: 第2版\",\"link\":\"/blog/译-JavaScript-The-Core-第2版\"},{\"text\":\"Modularization\",\"link\":\"/blog/Modularization\"}]}],\"/learn/\":[],\"/notes/\":[{\"text\":\"Notes\",\"link\":\"/notes/\",\"items\":[{\"text\":\"Sites\",\"link\":\"/notes/sites\"},{\"text\":\"Vue\",\"link\":\"/notes/Vue\"},{\"text\":\"JavaScript\",\"link\":\"/notes/JavaScript\"},{\"text\":\"Nginx\",\"link\":\"/notes/Nginx\"},{\"text\":\"Npm\",\"link\":\"/notes/Npm\"},{\"text\":\"CSS\",\"link\":\"/notes/CSS\"},{\"text\":\"Shell\",\"link\":\"/notes/Shell\"},{\"text\":\"Git\",\"link\":\"/notes/Git\"},{\"text\":\"RegExp\",\"link\":\"/notes/RegExp\"},{\"text\":\"Modularization\",\"link\":\"/notes/Modularization\"},{\"text\":\"微信小程序\",\"link\":\"/notes/wechat-miniprogram\"}]}],\"/reading/\":[{\"text\":\"Reading\",\"link\":\"/reading/\",\"items\":[{\"text\":\"Introduction\",\"link\":\"/reading/introduction\"}]}]},\"search\":{\"provider\":\"local\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>