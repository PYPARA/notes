<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>16 DOM2 和 DOM3 | PYPARA</title>
    <meta name="description" content="个人记录">
    <meta name="generator" content="VitePress v1.0.0-rc.44">
    <link rel="preload stylesheet" href="/notes/assets/style.CY2ccow2.css" as="style">
    
    <script type="module" src="/notes/assets/app.83FYqqNm.js"></script>
    <link rel="preload" href="/notes/assets/inter-roman-latin.Bu8hRsVA.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/notes/assets/chunks/framework.DhcZWzV3.js">
    <link rel="modulepreload" href="/notes/assets/chunks/theme.Bm6j8nIS.js">
    <link rel="modulepreload" href="/notes/assets/learn_JavaScript高级程序设计_16-DOM2和DOM3.md.ZoFmJAUE.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-19c990f1><div class="wrapper" data-v-19c990f1><div class="container" data-v-19c990f1><div class="title" data-v-19c990f1><div class="VPNavBarTitle" data-v-19c990f1 data-v-ab179fa1><a class="title" href="/notes/" data-v-ab179fa1><!--[--><!--]--><!----><span data-v-ab179fa1>PYPARA</span><!--[--><!--]--></a></div></div><div class="content" data-v-19c990f1><div class="content-body" data-v-19c990f1><!--[--><!--]--><div class="VPNavBarSearch search" data-v-19c990f1><!--[--><!----><div id="local-search"><button type="button" class="DocSearch DocSearch-Button" aria-label="Search"><span class="DocSearch-Button-Container"><span class="vp-icon DocSearch-Search-Icon"></span><span class="DocSearch-Button-Placeholder">Search</span></span><span class="DocSearch-Button-Keys"><kbd class="DocSearch-Button-Key"></kbd><kbd class="DocSearch-Button-Key">K</kbd></span></button></div><!--]--></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-19c990f1 data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink active" href="/notes/learn/introduction.html" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>Learn</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/notes/reading/introduction.html" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>Reading</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/notes/blog/introduction.html" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>Blog</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/notes/notes/sites.html" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>Notes</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-19c990f1 data-v-e6aabb21><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-e6aabb21 data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-19c990f1 data-v-0394ad82 data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/PYPARA" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-19c990f1 data-v-d0bd9dde data-v-b6c34ac9><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-b6c34ac9><span class="vpi-more-horizontal icon" data-v-b6c34ac9></span></button><div class="menu" data-v-b6c34ac9><div class="VPMenu" data-v-b6c34ac9 data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-d0bd9dde><div class="item appearance" data-v-d0bd9dde><p class="label" data-v-d0bd9dde>Appearance</p><div class="appearance-action" data-v-d0bd9dde><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="Switch to dark theme" aria-checked="false" data-v-d0bd9dde data-v-d1f28634 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-d1f28634></span><span class="vpi-moon moon" data-v-d1f28634></span><!--]--></span></span></button></div></div></div><div class="group" data-v-d0bd9dde><div class="item social-links" data-v-d0bd9dde><div class="VPSocialLinks social-links-list" data-v-d0bd9dde data-v-7bc22406><!--[--><a class="VPSocialLink no-icon" href="https://github.com/PYPARA" aria-label="github" target="_blank" rel="noopener" data-v-7bc22406 data-v-eee4e7cb><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-19c990f1 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-19c990f1><div class="divider-line" data-v-19c990f1></div></div></div><!----></header><div class="VPLocalNav empty fixed" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-d2ecc192><button data-v-d2ecc192>Return to top</button><!----></div></div></div><!----><div class="VPContent" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-3f215769 data-v-935f8a84><div class="content" data-v-935f8a84><div class="outline-marker" data-v-935f8a84></div><div class="outline-title" role="heading" aria-level="2" data-v-935f8a84>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-935f8a84><span class="visually-hidden" id="doc-outline-aria-label" data-v-935f8a84> Table of Contents for current page </span><ul class="VPDocOutlineItem root" data-v-935f8a84 data-v-b933a997><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _notes_learn_JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1_16-DOM2%E5%92%8CDOM3" data-v-39a288b8><div><h1 id="_16-dom2-和-dom3" tabindex="-1">16 DOM2 和 DOM3 <a class="header-anchor" href="#_16-dom2-和-dom3" aria-label="Permalink to &quot;16 DOM2 和 DOM3&quot;">​</a></h1><ul><li>DOM2 到 DOM3 的变化</li><li>操作样式的 DOM API</li><li>DOM 遍历与范围</li></ul><p>DOM1(DOM Level 1)主要定义了 HTML 和 XML 文档的底层结构。DOM2(DOM Level 2)和 DOM3(DOM Level 3)在这些结构之上加入更多交互能力，提供了更高级的 XML 特性。实际上，DOM2 和 DOM3 是按照模块化的思路来制定标准的，每个模块之间有一定关联，但分别针对某个 DOM 子集。</p><p>这些模式如下所示。</p><ul><li>DOM Core:在 DOM1 核心部分的基础上，为节点增加方法和属性。</li><li>DOM Views:定义基于样式信息的不同视图。</li><li>DOM Events:定义通过事件实现 DOM 文档交互。</li><li>DOM Style:定义以编程方式访问和修改 CSS 样式的接口。</li><li>DOM Traversal and Range:新增遍历 DOM 文档及选择文档内容的接口。</li><li>DOM HTML:在 DOM1 HTML 部分的基础上，增加属性、方法和新接口。</li><li>DOM Mutation Observers:定义基于 DOM 变化触发回调的接口。这个模块是 DOM4 级模块，用于取代 Mutation Events。</li></ul><h2 id="_16-1-dom-的演进" tabindex="-1">16.1 DOM 的演进 <a class="header-anchor" href="#_16-1-dom-的演进" aria-label="Permalink to &quot;16.1 DOM 的演进&quot;">​</a></h2><p>DOM2 和 DOM3 Core 模块的目标是扩展 DOM API，满足 XML 的所有需求并提供更好的错误处理 和特性检测。很大程度上，这意味着支持 XML 命名空间的概念。DOM2 Core 没有新增任何类型，仅仅 在 DOM1 Core 基础上增加了一些方法和属性。DOM3 Core 则除了增强原有类型，也新增了一些新类型。</p><p>类似地，DOM View 和 HTML 模块也丰富了 DOM 接口，定义了新的属性和方法。</p><h3 id="_16-1-1-xml-命名空间" tabindex="-1">16.1.1 XML 命名空间 <a class="header-anchor" href="#_16-1-1-xml-命名空间" aria-label="Permalink to &quot;16.1.1 XML 命名空间&quot;">​</a></h3><p>XML 命名空间可以实现在一个格式规范的文档中混用不同的 XML 语言，而不必担心元素命名冲 17 突。严格来讲，XML 命名空间在 XHTML 中才支持，HTML 并不支持。</p><p>命名空间是使用 xmlns 指定的。XHTML 的命名空间是<code>http://www.w3.org/1999/xhtml</code>，应该包含在任何格式规范的 XHTML 页面的 <code>&lt;html&gt;</code> 元素中</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> xmlns</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://www.w3.org/1999/xhtml&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Example XHTML page&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Hello world!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>对这个例子来说，所有元素都默认属于 XHTML 命名空间。可以使用 xmlns 给命名空间创建一个前缀，格式为“xmlns: 前缀”</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">xhtml:html</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> xmlns:xhtml</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://www.w3.org/1999/xhtml&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; &lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">xhtml:head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">xhtml:title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Example XHTML page&lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">xhtml:title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">xhtml:head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">xhtml:body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Hello world!</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">xhtml:body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;">xhtml:html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h4 id="_1-node-的变化" tabindex="-1">1. Node 的变化 <a class="header-anchor" href="#_1-node-的变化" aria-label="Permalink to &quot;1. Node 的变化&quot;">​</a></h4><p>在 DOM2 中，Node 类型包含以下特定于命名空间的属性:</p><ul><li><code>localName</code>，不包含命名空间前缀的节点名;</li><li><code>namespaceURI</code>，节点的命名空间 URL，如果未指定则为 <code>null</code>;</li><li><code>prefix</code>，命名空间前缀，如果未指定则为 <code>null</code>。</li></ul><p>DOM3 进一步增加了如下与命名空间相关的方法:</p><ul><li><code>isDefaultNamespace(namespaceURI)</code>，返回布尔值，表示 <code>namespaceURI</code> 是否为节点的默认命名空间;</li><li><code>lookupNamespaceURI(prefix)</code>，返回给定 <code>prefix</code> 的命名空间 <code>URI</code>;</li><li><code>lookupPrefix(namespaceURI)</code>，返回给定 <code>namespaceURI</code> 的前缀。</li></ul><h4 id="_2-document-的变化" tabindex="-1">2. Document 的变化 <a class="header-anchor" href="#_2-document-的变化" aria-label="Permalink to &quot;2. Document 的变化&quot;">​</a></h4><p>DOM2 在 Document 类型上新增了如下命名空间特定的方法:</p><ul><li><code>createElementNS(namespaceURI, tagName)</code>，以给定的标签名 <code>tagName</code> 创建指定命名空间 <code>namespaceURI</code> 的一个新元素;</li><li><code>createAttributeNS(namespaceURI, attributeName)</code>，以给定的属性名 <code>attributeName</code> 创建指定命名空间 <code>namespaceURI</code> 的一个新属性;</li><li><code>getElementsByTagNameNS(namespaceURI, tagName)</code>，返回指定命名空间 <code>namespaceURI</code> 中所有标签名为 <code>tagName</code> 的元素的 <code>NodeList</code>。</li></ul><h4 id="_3-element-的变化" tabindex="-1">3. Element 的变化 <a class="header-anchor" href="#_3-element-的变化" aria-label="Permalink to &quot;3. Element 的变化&quot;">​</a></h4><p>DOM2 Core 对 Element 类型的更新主要集中在对属性的操作上。下面是新增的方法:</p><ul><li><code>getAttributeNS(namespaceURI, localName)</code>，取得指定命名空间 <code>namespaceURI</code> 中名为 <code>localName</code> 的属性;</li><li><code>getAttributeNodeNS(namespaceURI, localName)</code>，取得指定命名空间 <code>namespaceURI</code> 中名为 <code>localName</code> 的属性节点;</li><li><code>getElementsByTagNameNS(namespaceURI, tagName)</code>，取得指定命名空间 <code>namespaceURI</code> 中标签名为 <code>tagName</code> 的元素的 <code>NodeList</code>;</li><li><code>hasAttributeNS(namespaceURI, localName)</code>，返回布尔值，表示元素中是否有命名空间 <code>namespaceURI</code> 下名为 <code>localName</code> 的属性(注意，DOM2 Core 也添加不带命名空间的 <code>hasAttribute()</code> 方法);</li><li><code>removeAttributeNS(namespaceURI, localName)</code>，删除指定命名空间 <code>namespaceURI</code> 中名为 <code>localName</code> 的属性;</li><li><code>setAttributeNS(namespaceURI, qualifiedName, value)</code>，设置指定命名空间 <code>namespaceURI</code> 中名为 <code>qualifiedName</code> 的属性为 <code>value</code>;</li><li><code>setAttributeNodeNS(attNode)</code>，为元素设置(添加)包含命名空间信息的属性节点 <code>attNode</code>。</li></ul><h4 id="_4-namednodemap-的变化" tabindex="-1">4. NamedNodeMap 的变化 <a class="header-anchor" href="#_4-namednodemap-的变化" aria-label="Permalink to &quot;4. NamedNodeMap 的变化&quot;">​</a></h4><p><code>NamedNodeMap</code> 也增加了以下处理命名空间的方法。因为 <code>NamedNodeMap</code> 主要表示属性，所以这些方法大都适用于属性:</p><ul><li><code>getNamedItemNS(namespaceURI, localName)</code>，取得指定命名空间 <code>namespaceURI</code> 中名为 <code>localName</code> 的项;</li><li><code>removeNamedItemNS(namespaceURI, localName)</code>，删除指定命名空间 <code>namespaceURI</code> 中 名为 <code>localName</code> 的项;</li><li><code>setNamedItemNS(node)</code>，为元素设置(添加)包含命名空间信息的节点。</li></ul><h3 id="_16-1-2-其他变化" tabindex="-1">16.1.2 其他变化 <a class="header-anchor" href="#_16-1-2-其他变化" aria-label="Permalink to &quot;16.1.2 其他变化&quot;">​</a></h3><p>除命名空间相关的变化，DOM2 Core 还对 DOM 的其他部分做了一些更新。这些变化与 XML 命名空间无关，主要关注 DOM API 的完整性与可靠性。</p><h4 id="_1-documenttype-的变化" tabindex="-1">1. DocumentType 的变化 <a class="header-anchor" href="#_1-documenttype-的变化" aria-label="Permalink to &quot;1. DocumentType 的变化&quot;">​</a></h4><p><code>DocumentType</code> 新增了 3 个属性:<code>publicId</code>、<code>systemId</code> 和 <code>internalSubset</code>。<code>publicId</code>、 <code>systemId</code> 属性表示文档类型声明中有效但无法使用 DOM1 API 访问的数据。</p><h4 id="_2-document-的变化-1" tabindex="-1">2. Document 的变化 <a class="header-anchor" href="#_2-document-的变化-1" aria-label="Permalink to &quot;2. Document 的变化&quot;">​</a></h4><p><code>Document</code> 类型的更新中唯一跟命名空间无关的方法是 <code>importNode()</code>。这个方法的目的是从其他文档获取一个节点并导入到新文档，以便将其插入新文档。每个节点都有一个 <code>ownerDocument</code> 属性， 表示所属文档。如果调用 <code>appendChild()</code> 方法时传入节点的 <code>ownerDocument</code> 不是指向当前文档，则 会发生错误。而调用 <code>importNode()</code> 导入其他文档的节点会返回一个新节点，这个新节点的 <code>ownerDocument</code> 属性是正确的。</p><p><code>importNode()</code> 方法跟 <code>cloneNode()</code> 方法类似，同样接收两个参数:要复制的节点和表示是否同时复制子树的布尔值，返回结果是适合在当前文档中使用的新节点。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">importNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(oldNode, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 导入节点及所有后代 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newNode);</span></span></code></pre></div><p>DOM2 View 给 <code>Document</code> 类型增加了新属性 <code>defaultView</code>，是一个指向拥有当前文档的窗口(或窗格<code>&lt;frame&gt;</code>)的指针。这个规范中并没有明确视图何时可用，因此这是添加的唯一一个属性。<code>defaultView</code> 属性得到了除 IE8 及更早版本之外所有浏览器的支持。IE8 及更早版本支持等价的 <code>parentWindow</code> 属性， Opera 也支持这个属性。</p><p>除了上面这一个方法和一个属性，DOM2 Core 还针对 <code>document.implementation</code> 对象增加了两 个新方法: <code>createDocumentType()</code> 和 <code>createDocument()</code>。前者用于创建 <code>DocumentType</code> 类型的新节点，接收 3 个参数:文档类型名称、<code>publicId</code> 和 <code>systemId</code>。</p><p>已有文档的文档类型不可更改，因此 <code>createDocumentType()</code> 只在创建新文档时才会用到，而创建新文档要使用 <code>createDocument()</code> 方法。<code>createDocument()</code> 接收 3 个参数:文档元素的 <code>namespaceURI</code>、文档元素的标签名和文档类型。</p><p>DOM2 HTML 模块也为 <code>document.implamentation</code> 对象添加了 <code>createHTMLDocument()</code> 方法。 使用这个方法可以创建一个完整的 <code>HTML</code> 文档，包含<code>&lt;html&gt;</code>、<code>&lt;head&gt;</code>、<code>&lt;title&gt;</code>和<code>&lt;body&gt;</code>元素。这个 方法只接收一个参数，即新创建文档的标题(放到<code>&lt;title&gt;</code>元素中)，返回一个新的 <code>HTML</code> 文档。</p><p><code>reateHTMLDocument() </code>方法创建的对象是 <code>HTMLDocument</code> 类型的实例，因此包括该类型所有相关的方法和属性，包括 <code>title</code> 和 <code>body</code> 属性。</p><h4 id="_3-node-的变化" tabindex="-1">3. Node 的变化 <a class="header-anchor" href="#_3-node-的变化" aria-label="Permalink to &quot;3. Node 的变化&quot;">​</a></h4><p>DOM3 新增了两个用于比较节点的方法: <code>isSameNode()</code> 和 <code>isEqualNode()</code>。这两个方法都接收一个节点参数，如果这个节点与参考节点相同或相等，则返回 <code>true</code>。节点相同，意味着引用同一个对象;节点相等，意味着节点类型相同，拥有相等的属性(<code>nodeName</code>、<code>nodeValue</code> 等)，而且 <code>attributes</code> 和 <code>childNodes</code> 也相等(即同样的位置包含相等的值)。</p><p>DOM3 也增加了给 DOM 节点附加额外数据的方法。<code>setUserData()</code> 方法接收 3 个参数:键、值、 处理函数，用于给节点追加数据。</p><h4 id="_4-内嵌窗格的变化" tabindex="-1">4. 内嵌窗格的变化 <a class="header-anchor" href="#_4-内嵌窗格的变化" aria-label="Permalink to &quot;4. 内嵌窗格的变化&quot;">​</a></h4><p>DOM2 HTML 给 HTMLIFrameElement(即<code>&lt;iframe&gt;</code>，内嵌窗格)类型新增了一个属性，叫 <code>contentDocument</code>。这个属性包含代表子内嵌窗格中内容的 <code>document</code> 对象的指针。</p><p><code>contentDocument</code> 属性是 <code>Document</code> 的实例，拥有所有文档属性和方法，因此可以像使用其他 HTML 文档一样使用它。还有一个属性 <code>contentWindow</code>，返回相应窗格的 <code>window</code> 对象，这个对象上 有一个 <code>document</code> 属性。所有现代浏览器都支持 <code>contentDocument</code> 和 <code>contentWindow</code> 属性。</p><h2 id="_16-2-样式" tabindex="-1">16.2 样式 <a class="header-anchor" href="#_16-2-样式" aria-label="Permalink to &quot;16.2 样式&quot;">​</a></h2><p>HTML 中的样式有 3 种定义方式:外部样式表(通过<code>&lt;link&gt;</code>元素)、文档样式表(使用<code>&lt;style&gt;</code>元素)和元素特定样式(使用 <code>style</code> 属性)。DOM2 <code>Style</code> 为这 3 种应用样式的机制都提供了 API。</p><h3 id="_16-2-1-存取元素样式" tabindex="-1">16.2.1 存取元素样式 <a class="header-anchor" href="#_16-2-1-存取元素样式" aria-label="Permalink to &quot;16.2.1 存取元素样式&quot;">​</a></h3><p>任何支持 <code>style</code> 属性的 <code>HTML</code> 元素在 <code>JavaScript</code> 中都会有一个对应的 <code>style</code> 属性。这个 <code>style</code> 属性是 <code>CSSStyleDeclaration</code> 类型的实例，其中包含通过 <code>HTML</code> <code>style</code> 属性为元素设置的所有样式信 息，<em><strong>但不包含通过层叠机制从文档样式和外部样式中继承来的样式</strong></em>。<code>HTML</code> <code>style</code> 属性中的 <code>CSS</code> 属性 在 <code>JavaScript</code> <code>style</code> 对象中都有对应的属性。因为 <code>CSS</code> 属性名使用连字符表示法(用连字符分隔两个单词，如 <code>background-image</code>)，所以在 <code>JavaScript</code> 中这些属性必须转换为驼峰大小写形式(如 <code>backgroundImage</code>)。</p><p>大多数属性名会这样直接转换过来。但有一个 CSS 属性名不能直接转换，它就是 <code>float</code>。因为 <code>float</code> 是 <code>JavaScript</code> 的保留字，所以不能用作属性名。DOM2 Style 规定它在 <code>style</code> 对象中对应的属性 应该是 <code>cssFloat</code>。</p><p>通过 <code>style</code> 属性设置的值也可以通过 <code>style</code> 对象获取。</p><p>如果元素上没有 <code>style</code> 属性，则 <code>style</code> 对象包含所有可能的 <code>CSS</code> 属性的空值。</p><h4 id="_1-dom-样式属性和方法" tabindex="-1">1. DOM 样式属性和方法 <a class="header-anchor" href="#_1-dom-样式属性和方法" aria-label="Permalink to &quot;1. DOM 样式属性和方法&quot;">​</a></h4><p>DOM2 Style 规范也在 <code>style</code> 对象上定义了一些属性和方法。这些属性和方法提供了元素 <code>style</code> 属性的信息并支持修改</p><ul><li><code>cssText</code>，包含 <code>style</code> 属性中的 <code>CSS</code> 代码。</li><li><code>length</code>，应用给元素的 <code>CSS </code>属性数量。</li><li><code>parentRule</code>，表示 <code>CSS</code> 信息的 <code>CSSRule</code> 对象(下一节会讨论 <code>CSSRule</code> 类型)。</li><li><code>getPropertyCSSValue(propertyName)</code>，返回包含 <code>CSS</code> 属性 <code>propertyName</code> 值的 <code>CSSValue</code> 对象(已废弃)。</li><li><code>getPropertyPriority(propertyName)</code>，如果 CSS 属性 <code>propertyName</code> 使用了<code>!important</code> 则返回<code>&quot;important&quot;</code>，否则返回空字符串。</li><li><code>getPropertyValue(propertyName)</code>，返回属性 <code>propertyName</code> 的字符串值。</li><li><code>item(index)</code>，返回索引为 <code>index</code> 的 <code>CSS</code> 属性名。</li><li><code>removeProperty(propertyName)</code>，从样式中删除 <code>CSS</code> 属性 <code>propertyName。</code></li><li><code>setProperty(propertyName, value, priority)</code>，设置 <code>CSS</code> 属性 <code>propertyName</code> 的值为 <code>value</code>，<code>priority </code>是<code>&quot;important&quot;</code>或空字符串。</li></ul><p>通过 <code>cssText</code> 属性可以存取样式的 <code>CSS</code> 代码。在读模式下，<code>cssText</code> 返回 <code>style</code> 属性 <code>CSS</code> 代码在浏览器内部的表示。在写模式下，给 <code>cssText</code> 赋值会重写整个 <code>style</code> 属性的值，意味着之前通过 <code>style</code> 属性设置的属性都会丢失。比如，如果一个元素通过 <code>style</code> 属性设置了边框，而赋给 <code>cssText</code> 属性的值不包含边框，则元素的边框会消失。</p><h4 id="_2-计算样式" tabindex="-1">2. 计算样式 <a class="header-anchor" href="#_2-计算样式" aria-label="Permalink to &quot;2. 计算样式&quot;">​</a></h4><p><code>style</code> 对象中包含支持 <code>style</code> 属性的元素为这个属性设置的样式信息，但不包含从其他样式表层叠继承的同样影响该元素的样式信息。DOM2 Style 在 <code>document.defaultView</code> 上增加了 <code>getComputedStyle()</code> 方法。这个方法接收两个参数:要取得计算样式的元素和伪元素字符串(如&quot;:after&quot;)。如果不需要查 询伪元素，则第二个参数可以传 <code>null</code>。<code>getComputedStyle()</code> 方法返回一个 <code>CSSStyleDeclaration</code> 对象(与 <code>style</code> 属性的类型一样)，包含元素的计算样式。</p><p>关于计算样式要记住一点，在所有浏览器中计算样式都是只读的，不能修改 <code>getComputedStyle()</code> 方法返回的对象。而且，计算样式还包含浏览器内部样式表中的信息。因此有默认值的 CSS 属性会出现 在计算样式里。例如，<code>visibility</code> 属性在所有浏览器中都有默认值，但这个值因实现而不同。</p><h3 id="_16-2-2-操作样式表" tabindex="-1">16.2.2 操作样式表 <a class="header-anchor" href="#_16-2-2-操作样式表" aria-label="Permalink to &quot;16.2.2 操作样式表&quot;">​</a></h3><p><code>CSSStyleSheet</code> 类型表示 <code>CSS</code> 样式表，包括使用<code>&lt;link&gt;</code>元素和通过<code>&lt;style&gt;</code>元素定义的样式表。 注意，这两个元素本身分别是 <code>HTMLLinkElement</code> 和 <code>HTMLStyleElement</code>。<code>CSSStyleSheet</code> 类型是一个通用样式表类型，可以表示以任何方式在 <code>HTML</code> 中定义的样式表。另外，元素特定的类型允许修改 <code>HTML</code> 属性，而 <code>CSSStyleSheet</code> 类型的实例则是一个只读对象(只有一个属性例外)。</p><p><code>CSSStyleSheet</code> 类型继承 <code>StyleSheet</code>，后者可用作非 <code>CSS</code> 样式表的基类。以下是 <code>CSSStyleSheet</code> 从 <code>StyleSheet</code> 继承的属性。</p><ul><li><code>disabled</code>，布尔值，表示样式表是否被禁用了(这个属性是可读写的，因此将它设置为 <code>true</code> 会禁用样式表)。</li><li><code>href</code>，如果是使用 <code>&lt;link&gt;</code> 包含的样式表，则返回样式表的 URL，否则返回 null。</li><li><code>media</code>，样式表支持的媒体类型集合，这个集合有一个 length 属性和一个 <code>item()</code> 方法，跟所 有 DOM 集合一样。同样跟所有 DOM 集合一样，也可以使用中括号访问集合中特定的项。如果样式表可用于所有媒体，则返回空列表。</li><li><code>ownerNode</code>，指向拥有当前样式表的节点，在 HTML 中要么是<code>&lt;link&gt;</code>元素要么是<code>&lt;style&gt;</code>元素(在 XML 中可以是处理指令)。如果当前样式表是通过 <code>@import</code> 被包含在另一个样式表中，则这 个属性值为 <code>null</code>。</li><li><code>parentStyleSheet</code>，如果当前样式表是通过 <code>@import</code> 被包含在另一个样式表中，则这个属性 指向导入它的样式表。</li><li><code>title</code>，<code>ownerNode</code> 的 <code>title</code> 属性。</li><li><code>type</code>，字符串，表示样式表的类型。对 <code>CSS</code> 样式表来说，就是 <code>&quot;text/css&quot;</code>。</li></ul><p>上述属性里除了 <code>disabled</code>，其他属性都是只读的。除了上面继承的属性，<code>CSSStyleSheet</code> 类型还支持以下属性和方法。</p><ul><li><code>cssRules</code>，当前样式表包含的样式规则的集合。</li><li><code>ownerRule</code>，如果样式表是使用 <code>@import</code> 导入的，则指向导入规则;否则为 <code>null</code>。</li><li><code>deleteRule(index)</code>，在指定位置删除 <code>cssRules</code> 中的规则。</li><li><code>insertRule(rule, index)</code>，在指定位置向 <code>cssRules</code> 中插入规则。</li></ul><p>通过 <code>&lt;link&gt;</code> 或 <code>&lt;style&gt;</code> 元素也可以直接获取 <code>CSSStyleSheet</code> 对象。DOM 在这两个元素上暴露了 <code>sheet</code> 属性，其中包含对应的 <code>CSSStyleSheet</code> 对象。</p><h4 id="_1-css-规则" tabindex="-1">1. CSS 规则 <a class="header-anchor" href="#_1-css-规则" aria-label="Permalink to &quot;1. CSS 规则&quot;">​</a></h4><p><code>CSSRule</code> 类型表示样式表中的一条规则。这个类型也是一个通用基类，很多类型都继承它，但其中最常用的是表示样式信息的 <code>CSSStyleRule</code>(其他 <code>CSS</code> 规则还有<code>@import</code>、<code>@font-face</code>、<code>@page</code> 和 <code>@charset</code> 等，不过这些规则很少需要使用脚本来操作)。以下是 <code>CSSStyleRule</code> 对象上可用的属性。</p><ul><li><code>cssText</code>，返回整条规则的文本。这里的文本可能与样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样。Safari 始终会把所有字母都转换为小写。</li><li><code>parentRule</code>，如果这条规则被其他规则(如<code>@media</code>)包含，则指向包含规则，否则就是 <code>null</code>。</li><li><code>parentStyleSheet</code>，包含当前规则的样式表。</li><li><code>selectorText</code>，返回规则的选择符文本。这里的文本可能与样式表中实际的文本不一样，因为浏览器内部处理样式表的方式也不一样。这个属性在 Firefox、Safari、Chrome 和 IE 中是只读的，在 Opera 中是可以修改的。</li><li><code>style</code>，返回 <code>CSSStyleDeclaration</code> 对象，可以设置和获取当前规则中的样式。</li><li><code>type</code>，数值常量，表示规则类型。对于样式规则，它始终为 1。</li></ul><h4 id="_2-创建规则" tabindex="-1">2. 创建规则 <a class="header-anchor" href="#_2-创建规则" aria-label="Permalink to &quot;2. 创建规则&quot;">​</a></h4><p>DOM 规定，可以使用 <code>insertRule()</code> 方法向样式表中添加新规则。这个方法接收两个参数:规则的文本和表示插入位置的索引值。</p><p>虽然可以这样添加规则，但随着要维护的规则增多，很快就会变得非常麻烦。这时候，更好的方式 是使用动态样式加载技术。</p><h4 id="_3-删除规则" tabindex="-1">3. 删除规则 <a class="header-anchor" href="#_3-删除规则" aria-label="Permalink to &quot;3. 删除规则&quot;">​</a></h4><p>支持从样式表中删除规则的 DOM 方法是 <code>deleteRule()</code>，它接收一个参数:要删除规则的索引。</p><p>与添加规则一样，删除规则并不是 Web 开发中常见的做法。考虑到可能影响 CSS 层叠的效果，删除规则时要慎重。</p><h3 id="_16-2-3-元素尺寸" tabindex="-1">16.2.3 元素尺寸 <a class="header-anchor" href="#_16-2-3-元素尺寸" aria-label="Permalink to &quot;16.2.3 元素尺寸&quot;">​</a></h3><p>本节介绍的属性和方法并不是 DOM2 Style 规范中定义的，但与 HTML 元素的样式有关。DOM 一直缺乏页面中元素实际尺寸的规定。IE 率先增加了一些属性，向开发者暴露元素的尺寸信息。这些属性现在已经得到所有主流浏览器支持。</p><h4 id="_1-偏移尺寸" tabindex="-1">1. 偏移尺寸 <a class="header-anchor" href="#_1-偏移尺寸" aria-label="Permalink to &quot;1. 偏移尺寸&quot;">​</a></h4><p>第一组属性涉及偏移尺寸(offset dimensions)，包含元素在屏幕上占用的所有视觉空间。元素在页 面上的视觉空间由其高度和宽度决定，包括所有内边距、滚动条和边框(但不包含外边距)。以下 4 个属性用于取得元素的偏移尺寸。</p><ul><li><code>offsetHeight</code>，元素在垂直方向上占用的像素尺寸，包括它的高度、水平滚动条高度(如果可见)和上、下边框的高度。</li><li><code>offsetLeft</code>，元素左边框外侧距离包含元素左边框内侧的像素数。</li><li><code>offsetTop</code>，元素上边框外侧距离包含元素上边框内侧的像素数。</li><li><code>offsetWidth</code>，元素在水平方向上占用的像素尺寸，包括它的宽度、垂直滚动条宽度(如果可见)和左、右边框的宽度。</li></ul><p>其中，<code>offsetLeft</code> 和 <code>offsetTop</code> 是相对于包含元素的，包含元素保存在 <code>offsetParent</code> 属性中。<code>offsetParent</code> 不一定是 <code>parentNode</code>。比如，<code>&lt;td&gt;</code>元素的 <code>offsetParent</code> 是作为其祖先的 <code>&lt;table&gt;</code> 元素，因为<code>&lt;table&gt;</code> 是节点层级中第一个提供尺寸的元素。</p><p>要确定一个元素在页面中的偏移量，可以把它的 <code>offsetLeft</code> 和 <code>offsetTop</code> 属性分别与 <code>offsetParent</code> 的相同属性相加，一直加到根元素。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getElementLeft</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> actualLeft </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.offsetLeft;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.offsetParent;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    actualLeft </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.offsetLeft;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.offsetParent; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">27</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> actualLeft;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getElementTop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">element</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> actualTop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.offsetTop;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.offsetParent;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    actualTop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.offsetTop;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    current </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> current.offsetParent;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> actualTop;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这两个函数使用 <code>offsetParent</code> 在 DOM 树中逐级上溯，将每一级的偏移属性相加，最终得到元 素的实际偏移量。对于使用 CSS 布局的简单页面，这两个函数是很精确的。而对于使用表格和内嵌窗 格的页面布局，它们返回的值会因浏览器不同而有所差异，因为浏览器实现这些元素的方式不同。一 般来说，包含在 <code>&lt;div&gt;</code> 元素中所有元素都以 <code>&lt;body&gt;</code> 为其 <code>offsetParent</code>，因此 <code>getElementleft()</code> 和 <code>getElementTop()</code> 返回的值与 <code>offsetLeft</code> 和 <code>offsetTop</code> 返回的值相同。</p><h4 id="_2-客户端尺寸" tabindex="-1">2. 客户端尺寸 <a class="header-anchor" href="#_2-客户端尺寸" aria-label="Permalink to &quot;2. 客户端尺寸&quot;">​</a></h4><p>元素的客户端尺寸(client dimensions)包含元素内容及其内边距所占用的空间。客户端尺寸只有两个相关属性:<code>clientWidth</code> 和 <code>clientHeight</code>。其中，<code>clientWidth</code> 是内容区宽度加左、右内边距宽度，<code>clientHeight</code> 是内容区高度加上、下内边距高度。</p><p>客户端尺寸实际上就是元素内部的空间，因此不包含滚动条占用的空间。这两个属性最常用于确定 浏览器视口尺寸，即检测 <code>document.documentElement</code> 的 <code>clientWidth</code> 和 <code>clientHeight</code>。这两个 属性表示视口<code>(&lt;html&gt;</code>或<code>&lt;body&gt;</code>元素)的尺寸。</p><h4 id="_3-滚动尺寸" tabindex="-1">3. 滚动尺寸 <a class="header-anchor" href="#_3-滚动尺寸" aria-label="Permalink to &quot;3. 滚动尺寸&quot;">​</a></h4><p>最后一组尺寸是滚动尺寸(scroll dimensions)，提供了元素内容滚动距离的信息。有些元素，比如 <code>&lt;html&gt;</code> 无须任何代码就可以自动滚动，而其他元素则需要使用 <code>CSS</code> 的 <code>overflow</code> 属性令其滚动。</p><ul><li><code>scrollHeight</code>，没有滚动条出现时，元素内容的总高度。</li><li><code>scrollLeft</code>，内容区左侧隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li><li><code>scrollTop</code>，内容区顶部隐藏的像素数，设置这个属性可以改变元素的滚动位置。</li><li><code>scrollWidth</code>，没有滚动条出现时，元素内容的总宽度。</li></ul><p><code>scrollWidth</code> 和 <code>scrollHeight</code> 可以用来确定给定元素内容的实际尺寸。例如，<code>&lt;html&gt;</code> 元素是浏览器中滚动视口的元素。因此，<code>document.documentElement.scrollHeight</code> 就是整个页面垂直方向的总高度。</p><p><code>scrollWidth</code> 和 <code>scrollHeight</code> 与 <code>clientWidth</code> 和 <code>clientHeight</code> 之间的关系在不需要滚动的文档上是分不清的。如果文档尺寸超过视口尺寸，则在所有主流浏览器中这两对属性都不相等， <code>scrollWidth</code> 和 <code>scollHeight</code> 等于文档内容的宽度，而 <code>clientWidth</code> 和 <code>clientHeight</code> 等于视口的大小。</p><p><code>scrollLeft</code> 和 <code>scrollTop</code> 属性可以用于确定当前元素滚动的位置，或者用于设置它们的滚动位置。元素在未滚动时，这两个属性都等于 <code>0</code>。如果元素在垂直方向上滚动，则 <code>scrollTop</code> 会大于 <code>0</code>， 表示元素顶部不可见区域的高度。如果元素在水平方向上滚动，则 <code>scrollLeft</code> 会大于 <code>0</code>，表示元素左侧不可见区域的宽度。因为这两个属性也是可写的，所以把它们都设置为 <code>0</code> 就可以重置元素的滚动位置。</p><h4 id="_4-确定元素尺寸" tabindex="-1">4. 确定元素尺寸 <a class="header-anchor" href="#_4-确定元素尺寸" aria-label="Permalink to &quot;4. 确定元素尺寸&quot;">​</a></h4><p>浏览器在每个元素上都暴露了 <code>getBoundingClientRect()</code> 方法，返回一个 <code>DOMRect</code> 对象，包含 6 个属性:<code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code>、<code>height</code> 和 <code>width</code>。这些属性给出了元素在页面中相对于视口的位置。</p><h2 id="_16-3-遍历" tabindex="-1">16.3 遍历 <a class="header-anchor" href="#_16-3-遍历" aria-label="Permalink to &quot;16.3 遍历&quot;">​</a></h2><p>DOM2 Traversal and Range 模块定义了两个类型用于辅助顺序遍历 DOM 结构。这两个类型 —— <code>NodeIterator</code> 和 <code>TreeWalker</code> ——从某个起点开始执行对 DOM 结构的深度优先遍历。</p><p>DOM 遍历是对 DOM 结构的深度优先遍历，至少允许朝两个方向移动(取决于类型)。 遍历以给定节点为根，不能在 DOM 中向上超越这个根节点。</p><h3 id="_16-3-1-nodeiterator" tabindex="-1">16.3.1 NodeIterator <a class="header-anchor" href="#_16-3-1-nodeiterator" aria-label="Permalink to &quot;16.3.1 NodeIterator&quot;">​</a></h3><p><code>NodeIterator</code> 类型是两个类型中比较简单的，可以通过 <code>document.createNodeIterator()</code> 方法创建其实例。这个方法接收以下 4 个参数。</p><ul><li><code>root</code>，作为遍历根节点的节点。</li><li><code>whatToShow</code>，数值代码，表示应该访问哪些节点。</li><li><code>filter</code>，<code>NodeFilter</code> 对象或函数，表示是否接收或跳过特定节点。</li><li><code>entityReferenceExpansion</code>，布尔值，表示是否扩展实体引用。这个参数在 HTML 文档中没有效果，因为实体引用永远不扩展。</li></ul><p><code>whatToShow</code> 参数是一个位掩码，通过应用一个或多个过滤器来指定访问哪些节点。这个参数对应的常量是在 <code>NodeFilter</code> 类型中定义的。</p><ul><li><code>NodeFilter.SHOW_ALL</code>，所有节点。</li><li><code>NodeFilter.SHOW_ELEMENT</code>，元素节点。</li><li><code>NodeFilter.SHOW_ATTRIBUTE</code>，属性节点。由于 DOM 的结构，因此实际上用不上。</li><li><code>NodeFilter.SHOW_TEXT</code>，文本节点。</li><li><code>NodeFilter.SHOW_CDATA_SECTION</code>，CData 区块节点。不是在 HTML 页面中使用的。</li><li><code>NodeFilter.SHOW_ENTITY_REFERENCE</code>，实体引用节点。不是在 HTML 页面中使用的。</li><li><code>NodeFilter.SHOW_ENTITY</code>，实体节点。不是在 HTML 页面中使用的。</li><li><code>NodeFilter.SHOW_PROCESSING_INSTRUCTION</code>，处理指令节点。不是在 HTML 页面中使用的。  NodeFilter.SHOW_COMMENT，注释节点。</li><li><code>NodeFilter.SHOW_DOCUMENT</code>，文档节点。</li><li><code>NodeFilter.SHOW_DOCUMENT_TYPE</code>，文档类型节点。</li><li><code>NodeFilter.SHOW_DOCUMENT_FRAGMENT</code>，文档片段节点。不是在 HTML 页面中使用的。</li><li><code>NodeFilter.SHOW_NOTATION</code>，记号节点。不是在 HTML 页面中使用的。</li></ul><p>这些值除了 <code>NodeFilter.SHOW_ALL</code> 之外，都可以组合使用。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> whatToShow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NodeFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SHOW_ELEMENT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> NodeFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SHOW_TEXT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><p><code>createNodeIterator()</code> 方法的 <code>filter</code> 参数可以用来指定自定义 <code>NodeFilter</code> 对象，或者一个 作为节点过滤器的函数。<code>NodeFilter</code> 对象只有一个方法 <code>acceptNode()</code>，如果给定节点应该访问就返 回 <code>NodeFilter</code>.<code>FILTER_ACCEPT</code>，否则返回 <code>NodeFilter.FILTER_SKIP</code>。因为 <code>NodeFilter</code> 是一个 抽象类型，所以不可能创建它的实例。只要创建一个包含 <code>acceptNode()</code> 的对象，然后把它传给 <code>createNodeIterator()</code> 就可以了。以下代码定义了只接收<code>&lt;p&gt;</code>元素的节点过滤器对象:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> filter </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  acceptNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.tagName.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLowerCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;p&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      NodeFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FILTER_ACCEPT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      NodeFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FILTER_SKIP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> iterator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createNodeIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root, NodeFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SHOW_ELEMENT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, filter, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><code>filter</code> 参数还可以是一个函数，与 <code>acceptNode()</code> 的形式一样</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> filter</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">node</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node.tagName.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toLowerCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;p&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    NodeFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FILTER_ACCEPT</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    NodeFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FILTER_SKIP</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> iterator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createNodeIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(root, NodeFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SHOW_ELEMENT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, filter, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>通常，<code>JavaScript</code> 会使用这种形式，因为更简单也更像普通 <code>JavaScript</code> 代码。如果不需要指定过滤器，则可以给这个参数传入 <code>null</code>。</p><p>要创建一个简单的遍历所有节点的 <code>NodeIterator</code>，可以使用以下代码:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> iterator </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createNodeIterator</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document, NodeFilter.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SHOW_ALL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p><code>NodeIterator</code> 的两个主要方法是 <code>nextNode()</code> 和 <code>previousNode()</code>。<code>nextNode()</code> 方法在 DOM 子树中以深度优先方式进前一步，而 previousNode()则是在遍历中后退一步。创建 NodeIterator 对象的时候，会有一个内部指针指向根节点，因此第一次调用 nextNode()返回的是根节点。当遍历到 达 DOM 树最后一个节点时，nextNode()返回 null。previousNode()方法也是类似的。当遍历到达 DOM 树最后一个节点时，调用 previousNode()返回遍历的根节点后，再次调用也会返回 <code>null</code>。</p><h3 id="_16-3-2-treewalker" tabindex="-1">16.3.2 TreeWalker <a class="header-anchor" href="#_16-3-2-treewalker" aria-label="Permalink to &quot;16.3.2 TreeWalker&quot;">​</a></h3><p><code>TreeWalker</code> 是 <code>NodeIterator</code> 的高级版。除了包含同样的 <code>nextNode()</code>、<code>previousNode()</code> 方法， <code>TreeWalker</code> 还添加了如下在 <code>DOM</code> 结构中向不同方向遍历的方法。</p><ul><li><code>parentNode()</code>，遍历到当前节点的父节点。</li><li><code>firstChild()</code>，遍历到当前节点的第一个子节点。</li><li><code>lastChild()</code>，遍历到当前节点的最后一个子节点。</li><li><code>nextSibling()</code>，遍历到当前节点的下一个同胞节点。</li><li><code>previousSibling()</code>，遍历到当前节点的上一个同胞节点。</li></ul><p><code>TreeWalker</code> 对象要调用 <code>document.createTreeWalker()</code> 方法来创建，这个方法接收与 <code>document.createNodeIterator()</code> 同样的参数:作为遍历起点的根节点、要查看的节点类型、节点 过滤器和一个表示是否扩展实体引用的布尔值。因为两者很类似，所以 <code>TreeWalker</code> 通常可以取代 <code>NodeIterator</code>。</p><p>不同的是，节点过滤器(<code>filter</code>)除了可以返回 <code>NodeFilter.FILTER_ACCEPT</code> 和 <code>NodeFilter</code>. <code>FILTER_SKIP</code>，还可以返回 <code>NodeFilter.FILTER_REJECT</code>。在使用 <code>NodeIterator</code> <code>时，NodeFilter</code>. <code>FILTER_SKIP</code> 和<code>NodeFilter.FILTER_REJECT</code> 是一样的。但在使用 <code>TreeWalker</code> 时，<code>NodeFilter.FILTER_SKIP</code> 表示跳过节点，访问子树中的下一个节点，而 <code>NodeFilter.FILTER_REJECT</code> 则表示跳过该节点以及该节点的整个子树。</p><p><code>TreeWalker</code> 类型也有一个名为 <code>currentNode</code> 的属性，表示遍历过程中上一次返回的节点(无论使用的是哪个遍历方法)。可以通过修改这个属性来影响接下来遍历的起点。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> walker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nextNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(node </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> walker.currentNode); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">walker.currentNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.body; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 修改起点</span></span></code></pre></div><p>相比于 <code>NodeIterator</code>，<code>TreeWalker</code> 类型为遍历 DOM 提供了更大的灵活性。</p><h2 id="_16-4-范围" tabindex="-1">16.4 范围 <a class="header-anchor" href="#_16-4-范围" aria-label="Permalink to &quot;16.4 范围&quot;">​</a></h2><p>为了支持对页面更细致的控制，DOM2 Traversal and Range 模块定义了范围接口。范围可用于在文档中选择内容，而不用考虑节点之间的界限。(选择在后台发生，用户是看不到的。)范围在常规 DOM 操作的粒度不够时可以发挥作用。</p><p>DOM2 在 Document 类型上定义了一个 <code>createRange()</code> 方法，暴露在 <code>document</code> 对象上。使用这个方法可以创建一个 DOM 范围对象</p><p>与节点类似，这个新创建的范围对象是与创建它的文档关联的，不能在其他文档中使用。然后可以 使用这个范围在后台选择文档特定的部分。创建范围并指定它的位置之后，可以对范围的内容执行一些 操作，从而实现对底层 DOM 树更精细的控制。</p><p>每个范围都是 <code>Range</code> 类型的实例，拥有相应的属性和方法。</p><ul><li><code>startContainer</code>，范围起点所在的节点(选区中第一个子节点的父节点)。</li><li><code>startOffset</code>，范围起点在 <code>startContainer</code> 中的偏移量。如果 <code>startContainer</code> 是文本节 点、注释节点或 CData 区块节点，则 <code>startOffset</code> 指范围起点之前跳过的字符数;否则，表示范围中第一个节点的索引。</li><li><code>endContainer</code>，范围终点所在的节点(选区中最后一个子节点的父节点)。</li><li><code>endOffset</code>，范围起点在 <code>startContainer</code> 中的偏移量(与 <code>startOffset</code> 中偏移量的含义相同)。</li><li><code>commonAncestorContainer</code>，文档中以 <code>startContainer</code> 和 <code>endContainer</code> 为后代的最深的节点。</li></ul><h3 id="_16-4-2-简单选择" tabindex="-1">16.4.2 简单选择 <a class="header-anchor" href="#_16-4-2-简单选择" aria-label="Permalink to &quot;16.4.2 简单选择&quot;">​</a></h3><p>通过范围选择文档中某个部分最简单的方式，就是使用 <code>selectNode()</code> 或 <code>selectNodeContents()</code> 方法。这两个方法都接收一个节点作为参数，并将该节点的信息添加到调用它的范围。<code>selectNode()</code> 方法选择整个节点，包括其后代节点，而 <code>selectNodeContents()</code> 只选择节点的后代。</p><p>调用 <code>selectNode()</code> 时，<code>startContainer</code>、<code>endContainer</code> 和 <code>commonAncestorContainer</code> 都等于传入节点的父节点。</p><p>在调用 <code>selectNodeContents()</code> 时，<code>startContainer</code>、<code>endContainer</code> 和 <code>commonAncestorContainer </code>属性就是传入的节点。</p><p>在像上面这样选定节点或节点后代之后，还可以在范围上调用相应的方法，实现对范围中选区的更精细控制。</p><ul><li><code>setStartBefore(refNode)</code>，把范围的起点设置到 <code>refNode</code> 之前，从而让 <code>refNode</code> 成为选区的第一个子节点。<code>startContainer</code> 属性被设置为 <code>refNode.parentNode</code>，而 <code>startOffset</code> 属性被设置为 <code>refNode</code> 在其父节点 <code>childNodes</code> 集合中的索引。</li><li><code>setStartAfter(refNode)</code>，把范围的起点设置到 <code>refNode</code> 之后，从而将 <code>refNode</code> 排除在选区之外，让其下一个同胞节点成为选区的第一个子节点。<code>startContainer</code> 属性被设置为 <code>refNode.parentNode</code>，<code>startOffset</code> 属性被设置为 <code>refNode</code> 在其父节点 <code>childNodes</code> 集合中的索引加 1。</li><li><code>setEndBefore(refNode)</code>，把范围的终点设置到 <code>refNode</code> 之前，从而将 <code>refNode</code> 排除在选区之外、让其上一个同胞节点成为选区的最后一个子节点。<code>endContainer</code> 属性被设置为 <code>refNode</code>. <code>parentNode</code>，<code>endOffset</code> 属性被设置为 <code>refNode</code> 在其父节点 <code>childNodes</code> 集合中的索引。</li><li><code>setEndAfter(refNode)</code>，把范围的终点设置到 <code>refNode</code> 之后，从而让 <code>refNode</code> 成为选区的 最后一个子节点。e<code>ndContainer</code> 属性被设置为 <code>refNode.parentNode</code>，<code>endOffset</code> 属性被设置为 <code>refNode</code> 在其父节点 <code>childNodes</code> 集合中的索引加 1。</li></ul><p>调用这些方法时，所有属性都会自动重新赋值。不过，为了实现复杂的选区，也可以直接修改这些属性的值。</p><h3 id="_16-4-3-复杂选择" tabindex="-1">16.4.3 复杂选择 <a class="header-anchor" href="#_16-4-3-复杂选择" aria-label="Permalink to &quot;16.4.3 复杂选择&quot;">​</a></h3><p>要创建复杂的范围，需要使用 <code>setStart()</code> 和 <code>setEnd()</code> 方法。这两个方法都接收两个参数: 参照节点和偏移量。对 <code>setStart()</code> 来说，参照节点会成为 <code>startContainer</code>，而偏移量会赋值给 <code>startOffset</code>。 对 setEnd()而言，参照节点会成为 <code>endContainer</code>，而偏移量会赋值给 <code>endOffset</code>。</p><p>注意，要选择节点(使用 range1)，必须先确定给定节点(p1)在其父节点 <code>childNodes</code> 集合中 的索引。而要选择节点的内容(使用 range2)，则不需要这样计算，因为可以直接给 <code>setStart()</code> 和 <code>setEnd()</code> 传默认值。虽然可以模拟 <code>selectNode()</code> 和 <code>selectNodeContents()</code>，但 <code>setStart()</code> 和 <code>setEnd()</code> 真正的威力还是选择节点中的某个部分。</p><h3 id="_16-4-4-操作范围" tabindex="-1">16.4.4 操作范围 <a class="header-anchor" href="#_16-4-4-操作范围" aria-label="Permalink to &quot;16.4.4 操作范围&quot;">​</a></h3><p>创建范围之后，浏览器会在内部创建一个文档片段节点，用于包含范围选区中的节点。为操作范围的内容，选区中的内容必须格式完好。在前面的例子中，因为范围的起点和终点都在文本节点内部，并不是完好的 DOM 结构，所以无法在 DOM 中表示。不过，范围能够确定缺失的开始和结束标签，从而可以重构出有效的 DOM 结构，以便后续操作。</p><p>...</p><h3 id="_16-4-5-范围插入" tabindex="-1">16.4.5 范围插入 <a class="header-anchor" href="#_16-4-5-范围插入" aria-label="Permalink to &quot;16.4.5 范围插入&quot;">​</a></h3><p>使用 <code>insertNode()</code> 方法可以在范围选区的开始位置插入一个节点。</p><p>除了向范围中插入内容，还可以使用 <code>surroundContents()</code> 方法插入包含范围的内容。这个方法接收一个参数，即包含范围内容的节点。调用这个方法时，后台会执行如下操作:</p><ul><li>(1) 提取出范围的内容;</li><li>(2) 在原始文档中范围之前所在的位置插入给定的节点;</li><li>(3) 将范围对应文档片段的内容添加到给定节点。</li></ul><h3 id="_16-4-6-范围折叠" tabindex="-1">16.4.6 范围折叠 <a class="header-anchor" href="#_16-4-6-范围折叠" aria-label="Permalink to &quot;16.4.6 范围折叠&quot;">​</a></h3><p>如果范围并没有选择文档的任何部分，则称为折叠(collapsed)。折叠范围有点类似文本框:如果文本框中有文本，那么可以用鼠标选中以高亮显示全部文本。这时候，如果再单击鼠标，则选区会被移除，光标会落在某两个字符中间。而在折叠范围时，位置会被设置为范围与文档交界的地方，可能是范围选区的开始处，也可能是结尾处。</p><p>折叠范围可以使用 <code>collapse()</code> 方法，这个方法接收一个参数:布尔值，表示折叠到范围哪一端。 <code>true</code> 表示折叠到起点，<code>false</code> 表示折叠到终点。要确定范围是否已经被折叠，可以检测范围的 <code>collapsed</code> 属性。</p><p>测试范围是否被折叠，能够帮助确定范围中的两个节点是否相邻。</p><h3 id="_16-4-7-范围比较" tabindex="-1">16.4.7 范围比较 <a class="header-anchor" href="#_16-4-7-范围比较" aria-label="Permalink to &quot;16.4.7 范围比较&quot;">​</a></h3><p>如果有多个范围，则可以使用 <code>compareBoundaryPoints()</code> 方法确定范围之间是否存在公共的边界(起点或终点)。这个方法接收两个参数:要比较的范围和一个常量值，表示比较的方式。这个常量参数包括:</p><ul><li><code>Range.START_TO_START(0)</code>，比较两个范围的起点;</li><li><code>Range.START_TO_END(1)</code>，比较第一个范围的起点和第二个范围的终点;</li><li><code>Range.END_TO_END(2)</code>，比较两个范围的终点;</li><li><code>Range.END_TO_START(3)</code>，比较第一个范围的终点和第二个范围的起点。</li></ul><p><code>compareBoundaryPoints()</code> 方法在第一个范围的边界点位于第二个范围的边界点之前时返回-1， 在两个范围的边界点相等时返回 0，在第一个范围的边界点位于第二个范围的边界点之后时返回 1。</p><h3 id="_16-4-8-复制范围" tabindex="-1">16.4.8 复制范围 <a class="header-anchor" href="#_16-4-8-复制范围" aria-label="Permalink to &quot;16.4.8 复制范围&quot;">​</a></h3><p>调用范围的 <code>cloneRange()</code> 方法可以复制范围。</p><p>新范围包含与原始范围一样的属性，修改其边界点不会影响原始范围。</p><h3 id="_16-4-9-清理" tabindex="-1">16.4.9 清理 <a class="header-anchor" href="#_16-4-9-清理" aria-label="Permalink to &quot;16.4.9 清理&quot;">​</a></h3><p>在使用完范围之后，最好调用 <code>detach()</code> 方法把范围从创建它的文档中剥离。调用 <code>detach()</code> 之后，就可以放心解除对范围的引用，以便垃圾回收程序释放它所占用的内存。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">range.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">detach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 从文档中剥离范围 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">range </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 解除引用</span></span></code></pre></div><p>这两步是最合理的结束使用范围的方式。剥离之后的范围就不能再使用了。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>DOM2 规范定义了一些模块，用来丰富 DOM1 的功能。DOM2 Core 在一些类型上增加了与 XML 命名空间有关的新方法。这些变化只有在使用 XML 或 XHTML 文档时才会用到，在 HTML 文档中则没 有用处。DOM2 增加的与 XML 命名空间无关的方法涉及以编程方式创建 Document 和 DocumentType 类型的新实例。</p><p>DOM2 Style 模块定义了如何操作元素的样式信息。</p><ul><li>每个元素都有一个关联的 <code>style</code> 对象，可用于确定和修改元素特定的样式。</li><li>要确定元素的计算样式，包括应用到元素身上的所有 <code>CSS</code> 规则，可以使用 <code>getComputedStyle()</code> 方法。</li><li>通过 <code>document.styleSheets</code> 集合可以访问文档上所有的样式表。</li></ul><p>DOM2 Traversal and Range 模块定义了与 DOM 结构交互的不同方式。</p><ul><li><code>NodeIterator</code> 和 <code>TreeWalker</code> 可以对 DOM 树执行深度优先的遍历。</li><li><code>NodeIterator</code> 接口很简单，每次只能向前和向后移动一步。<code>TreeWalker</code> 除了支持同样的行为，还支持在 DOM 结构的所有方向移动，包括父节点、同胞节点和子节点。</li><li>范围是选择 DOM 结构中特定部分并进行操作的一种方式。</li><li>通过范围的选区可以在保持文档结构完好的同时从文档中移除内容，也可复制文档中相应的部分。</li></ul></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-09de1c0f><!--[--><!--]--><div class="edit-info" data-v-09de1c0f><!----><div class="last-updated" data-v-09de1c0f><p class="VPLastUpdated" data-v-09de1c0f data-v-7e05ebdb>Last updated: <time datetime="2023-02-09T06:33:51.000Z" data-v-7e05ebdb></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><footer class="VPFooter" data-v-5d98c3a5 data-v-e315a0ad><div class="container" data-v-e315a0ad><p class="message" data-v-e315a0ad>Powered by Vitepress</p><p class="copyright" data-v-e315a0ad>Copyright © PYPARA</p></div></footer><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"blog_introduction.md\":\"KgjVWHPm\",\"learn_javascript_0-javascript继承机制.md\":\"UMd2FdZo\",\"learn_effective-javascript_chapter3-working-with-functions.md\":\"lWH5vZRC\",\"learn_games101_linear-algebra.md\":\"1db608lV\",\"learn_effective-javascript_chapter1-accustoming-yourself-to-javascript.md\":\"7e5CoyUC\",\"learn_javascript高级程序设计_2-html中的javascript.md\":\"D_DlGwCE\",\"learn_effective-javascript_chapter2-variable-scope.md\":\"CiJSIri2\",\"learn_javascript高级程序设计_16-dom2和dom3.md\":\"ZoFmJAUE\",\"learn_javascript高级程序设计_13-客户端检测.md\":\"CvVn1ozE\",\"index.md\":\"DHJ-tfjV\",\"learn_javascript高级程序设计_1-什么是javascript.md\":\"BkAvRS3R\",\"learn_introduction.md\":\"hErMy9qO\",\"learn_effective-javascript_index.md\":\"CX2N2Mps\",\"learn_javascript_4-变量对象.md\":\"pUDK__ki\",\"notes_css.md\":\"DyEoahRP\",\"learn_effective-javascript_chapter4-objects-and-prototypes.md\":\"BVlnBKnd\",\"blog_译-javascript-the-core-第2版.md\":\"D4GgoT3n\",\"notes_git.md\":\"MsRhe70t\",\"learn_javascript_3-执行上下文栈.md\":\"Cdpk5_UU\",\"learn_javascript_11-bind的模拟实现.md\":\"Co7s0Lsb\",\"learn_javascript高级程序设计_4-变量、作用域与内存.md\":\"BBgU0R75\",\"notes_vue3相对路径部署.md\":\"CioGLUK2\",\"learn_javascript_7-执行上下文.md\":\"Bwp-Lx3F\",\"learn_javascript_13-类数组对象与arguments.md\":\"6bvZ2CnB\",\"learn_javascript高级程序设计_17-事件.md\":\"Cemp66ds\",\"learn_javascript高级程序设计_15-dom扩展.md\":\"DeHGcbC2\",\"learn_javascript高级程序设计_14-dom.md\":\"DObm8Pld\",\"learn_javascript_8-闭包.md\":\"BxETkvQr\",\"notes_javascript.md\":\"BIokBCVt\",\"learn_learn_浏览器渲染原理_浏览器渲染原理.md\":\"DKpi67-k\",\"learn_javascript_10-call和apply的模拟实现.md\":\"CIjaicBp\",\"learn_javascript_12-new的模拟实现.md\":\"BYxG-uFX\",\"learn_learn_浏览器渲染原理_面试题.md\":\"DoSRPfEm\",\"learn_javascript_2-词法作用域和动态作用域.md\":\"u7Sxmf20\",\"learn_javascript_6-this.md\":\"DyGIkv5v\",\"learn_javascript_5-作用域链.md\":\"DgExi5Tx\",\"learn_games101_introduction.md\":\"CgLdIucl\",\"learn_javascript高级程序设计_5-基本引用类型.md\":\"D5HMzSZT\",\"learn_javascript高级程序设计_3-语言基础.md\":\"B2GEQssS\",\"learn_javascript_14-创建对象的多种方式和优缺点.md\":\"Mgd-XHUU\",\"notes_npm.md\":\"Bmk4_HKK\",\"notes_nginx.md\":\"BUaPAZx4\",\"learn_learn_浏览器渲染原理_你不知道的 css 之包含块.md\":\"BnGKhdtj\",\"notes_regexp.md\":\"Di9JQTfe\",\"blog_modularization.md\":\"Ce2Q8oes\",\"notes_pdf.md\":\"C9YtcOlO\",\"learn_javascript_1-原型到原型链.md\":\"C2ENjBRa\",\"notes_wechat-miniprogram.md\":\"D4uRZ-U6\",\"notes_vue.md\":\"Ccu9PVaC\",\"reading_introduction.md\":\"DAMVFUoa\",\"learn_javascript高级程序设计_12-bom.md\":\"DU6e6VE1\",\"learn_learn_事件循环_课件.md\":\"COtooawv\",\"learn_javascript高级程序设计_8-对象、类与面向对象编程.md\":\"BvBrJ1w_\",\"learn_learn_事件循环_事件循环.md\":\"C8szPr3E\",\"learn_javascript高级程序设计_9-代理与反射.md\":\"DSv_4Zl8\",\"notes_shell.md\":\"Cu6lYPeJ\",\"notes_sites.md\":\"DYo9RFv0\",\"notes_others.md\":\"CWe2BS0t\",\"notes_modularization.md\":\"B5bu3Z-U\",\"learn_javascript高级程序设计_10-函数.md\":\"DtSsLdH7\",\"learn_javascript高级程序设计_index.md\":\"COZVgrry\",\"learn_javascript高级程序设计_11-期约与异步函数.md\":\"uA8pMjqo\",\"learn_learn_浏览器渲染原理_css 属性计算过程.md\":\"4yG-zYNm\",\"learn_javascript高级程序设计_7-迭代器与生成器.md\":\"WMzKiP3T\",\"learn_javascript高级程序设计_6-集合引用类型.md\":\"-Ptt9Lq4\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"PYPARA\",\"description\":\"个人记录\",\"base\":\"/notes/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"footer\":{\"message\":\"Powered by Vitepress\",\"copyright\":\"Copyright © PYPARA\"},\"socialLinks\":[{\"icon\":\"github\",\"link\":\"https://github.com/PYPARA\"}],\"nav\":[{\"text\":\"Learn\",\"link\":\"/learn/introduction\",\"activeMatch\":\"/learn/\"},{\"text\":\"Reading\",\"link\":\"/reading/introduction\",\"activeMatch\":\"/reading/\"},{\"text\":\"Blog\",\"link\":\"/blog/introduction\",\"activeMatch\":\"/blog/\"},{\"text\":\"Notes\",\"link\":\"/notes/sites\",\"activeMatch\":\"/notes/\"}],\"sidebar\":{\"/blog/\":[{\"text\":\"Blog\",\"link\":\"/blog/\",\"items\":[{\"text\":\"[译]JavaScript. The Core: 第2版\",\"link\":\"/blog/译-JavaScript-The-Core-第2版\"},{\"text\":\"Modularization\",\"link\":\"/blog/Modularization\"}]}],\"/learn/\":[],\"/notes/\":[{\"text\":\"Notes\",\"link\":\"/notes/\",\"items\":[{\"text\":\"Sites\",\"link\":\"/notes/sites\"},{\"text\":\"Vue\",\"link\":\"/notes/Vue\"},{\"text\":\"JavaScript\",\"link\":\"/notes/JavaScript\"},{\"text\":\"Nginx\",\"link\":\"/notes/Nginx\"},{\"text\":\"Npm\",\"link\":\"/notes/Npm\"},{\"text\":\"CSS\",\"link\":\"/notes/CSS\"},{\"text\":\"Shell\",\"link\":\"/notes/Shell\"},{\"text\":\"Git\",\"link\":\"/notes/Git\"},{\"text\":\"RegExp\",\"link\":\"/notes/RegExp\"},{\"text\":\"Modularization\",\"link\":\"/notes/Modularization\"},{\"text\":\"微信小程序\",\"link\":\"/notes/wechat-miniprogram\"}]}],\"/reading/\":[{\"text\":\"Reading\",\"link\":\"/reading/\",\"items\":[{\"text\":\"Introduction\",\"link\":\"/reading/introduction\"}]}]},\"search\":{\"provider\":\"local\"}},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>