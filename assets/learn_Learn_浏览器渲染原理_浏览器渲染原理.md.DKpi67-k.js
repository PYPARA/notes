import{_ as a,c as s,o as t,a4 as e}from"./chunks/framework.DhcZWzV3.js";const i="/notes/assets/渲染时间点.LNKj1j7T.png",n="/notes/assets/渲染流水线.D_Jbl1lU.png",r="/notes/assets/parseHTML.y9PxDorv.png",o="/notes/assets/DOM.C_uJL9rY.png",l="/notes/assets/CSSOM.CU6i8d0h.png",p="/notes/assets/CSS.D_1KWnBl.png",h="/notes/assets/JS.DMPQBM-r.png",c="/notes/assets/样式计算.DZGuVVUs.png",d="/notes/assets/Layout_1.X1zDF4HE.png",_="/notes/assets/Layout_2.C_Txf_FU.png",m="/notes/assets/Layout_3.C4FiLgrb.png",g="/notes/assets/Layer.BVmxQPjJ.png",k="/notes/assets/Paint_1.BzE5GLuH.png",u="/notes/assets/Paint_2.DBemfVGb.png",y="/notes/assets/Tiling_1.CQP0CqKU.png",b="/notes/assets/Tiling_2.BHzl_VNq.png",f="/notes/assets/Raster_1.Bv8c7i04.png",E="/notes/assets/Raster_2.Rtso0HL9.png",S="/notes/assets/Draw.gxVbaZPO.png",P="/notes/assets/All.Bh5LAt08.png",q="/notes/assets/reflow.w7nHG-5K.png",L="/notes/assets/repaint.CBNfT5nP.png",M="/notes/assets/transform_1.BPFiRVPH.png",C="/notes/assets/transform_2.CrWPFfh2.png",v=JSON.parse('{"title":"浏览器渲染原理","description":"","frontmatter":{},"headers":[],"relativePath":"learn/Learn/浏览器渲染原理/浏览器渲染原理.md","filePath":"learn/Learn/浏览器渲染原理/浏览器渲染原理.md","lastUpdated":1675924431000}'),D={name:"learn/Learn/浏览器渲染原理/浏览器渲染原理.md"},T=e('<h1 id="浏览器渲染原理" tabindex="-1">浏览器渲染原理 <a class="header-anchor" href="#浏览器渲染原理" aria-label="Permalink to &quot;浏览器渲染原理&quot;">​</a></h1><p>将 <code>HTML</code> 信息渲染成 像素 pixels 信息</p><h2 id="渲染时间点" tabindex="-1">渲染时间点 <a class="header-anchor" href="#渲染时间点" aria-label="Permalink to &quot;渲染时间点&quot;">​</a></h2><p>当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。 <img src="'+i+'" alt="渲染时间点"></p><h2 id="渲染流水线" tabindex="-1">渲染流水线 <a class="header-anchor" href="#渲染流水线" aria-label="Permalink to &quot;渲染流水线&quot;">​</a></h2><p>整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画</p><p>每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。</p><p>这样，整个渲染流程就形成了一套组织严密的生产流水线。 <img src="'+n+'" alt="渲染流水线"></p><h3 id="_1-解析-html-parse-html" tabindex="-1">1. 解析 HTML - Parse HTML <a class="header-anchor" href="#_1-解析-html-parse-html" aria-label="Permalink to &quot;1. 解析 HTML - Parse HTML&quot;">​</a></h3><p>解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。</p><p>如果主线程解析到<code>link</code>位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。</p><p>如果主线程解析到<code>script</code>位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。</p><p>第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。</p><p><img src="'+r+'" alt="parseHTML"></p><h4 id="document-object-model" tabindex="-1">Document Object Model <a class="header-anchor" href="#document-object-model" aria-label="Permalink to &quot;Document Object Model&quot;">​</a></h4><p><img src="'+o+'" alt="DOM"></p><h4 id="css-object-model" tabindex="-1">CSS Object Model <a class="header-anchor" href="#css-object-model" aria-label="Permalink to &quot;CSS Object Model&quot;">​</a></h4><p><img src="'+l+`" alt="DOM"><code>document.styleSheets</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> styleSheet</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.styleSheets[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(styleSheet.rules) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // rules 能访问时才能执行，否则会报错，部分访问不到</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  styleSheet.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addRule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;border: 2px solid red&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  styleSheet.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">insertRule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;div { border: 2px solid red }&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><img src="`+p+'" alt="CSS"><img src="'+h+'" alt="JS"></p><h3 id="_2-样式计算-recalculate-style" tabindex="-1">2. 样式计算 - Recalculate Style <a class="header-anchor" href="#_2-样式计算-recalculate-style" aria-label="Permalink to &quot;2. 样式计算 - Recalculate Style&quot;">​</a></h3><p>主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 <code>Computed Style</code>。</p><p>在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px</p><p>这一步完成后，会得到一棵带有样式的 DOM 树。 <img src="'+c+'" alt="样式计算"></p><h3 id="_3-布局-layout" tabindex="-1">3. 布局 - Layout <a class="header-anchor" href="#_3-布局-layout" aria-label="Permalink to &quot;3. 布局 - Layout&quot;">​</a></h3><p>DOM 树 和 Layout 树不一定是一一对应的</p><p><img src="'+d+'" alt="Layout"><img src="'+_+'" alt="Layout"><img src="'+m+'" alt="Layout"></p><p>布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。</p><p>大部分时候，DOM 树和布局树并非一一对应。</p><p>比如<code>display:none</code>的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。</p><h3 id="_4-分层-layer" tabindex="-1">4. 分层 - Layer <a class="header-anchor" href="#_4-分层-layer" aria-label="Permalink to &quot;4. 分层 - Layer&quot;">​</a></h3><p><img src="'+g+'" alt="Layer"></p><p>主线程会使用一套复杂的策略对整个布局树中进行分层。</p><p>分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。</p><p>滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过<code>will-change</code>属性更大程度的影响分层结果。</p><h3 id="_5-绘制-paint" tabindex="-1">5. 绘制 - Paint <a class="header-anchor" href="#_5-绘制-paint" aria-label="Permalink to &quot;5. 绘制 - Paint&quot;">​</a></h3><p>主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。 <img src="'+k+'" alt="Paint"><img src="'+u+'" alt="Paint"></p><h3 id="_6-分块-tiling" tabindex="-1">6. 分块 - Tiling <a class="header-anchor" href="#_6-分块-tiling" aria-label="Permalink to &quot;6. 分块 - Tiling&quot;">​</a></h3><p>完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。</p><p>合成线程首先对每个图层进行分块，将其划分为更多的小区域。</p><p>它会从线程池中拿取多个线程来完成分块工作。 <img src="'+y+'" alt="Tiling"><img src="'+b+'" alt="Tiling"></p><h3 id="_7-光栅化-raster" tabindex="-1">7. 光栅化 - Raster <a class="header-anchor" href="#_7-光栅化-raster" aria-label="Permalink to &quot;7. 光栅化 - Raster&quot;">​</a></h3><p>合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。</p><p>GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。</p><p>光栅化的结果，就是一块一块的位图 <img src="'+f+'" alt="Raster"><img src="'+E+'" alt="Raster"></p><h3 id="_8-画-draw" tabindex="-1">8. 画 - Draw <a class="header-anchor" href="#_8-画-draw" aria-label="Permalink to &quot;8. 画 - Draw&quot;">​</a></h3><p>合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。</p><p>指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。</p><p>变形发生在合成线程，与渲染主线程无关，这就是<code>transform</code>效率高的本质原因。</p><p>合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。 <img src="'+S+'" alt="Draw"></p><h3 id="完整过程" tabindex="-1">完整过程 <a class="header-anchor" href="#完整过程" aria-label="Permalink to &quot;完整过程&quot;">​</a></h3><p><img src="'+P+'" alt="All"></p><h2 id="什么是-reflow" tabindex="-1">什么是 reflow ？ <a class="header-anchor" href="#什么是-reflow" aria-label="Permalink to &quot;什么是 reflow ？&quot;">​</a></h2><p><img src="'+q+'" alt="reflow"> reflow 的本质就是重新计算 layout 树。</p><p>当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。比如修改几何信息。宽高等。</p><p>为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。</p><p>也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。比如获取<code>clientWidth</code>属性。</p><p>浏览器在反复权衡下，最终决定获取属性立即 reflow。</p><h2 id="什么是-repaint" tabindex="-1">什么是 repaint ？ <a class="header-anchor" href="#什么是-repaint" aria-label="Permalink to &quot;什么是 repaint ？&quot;">​</a></h2><p><img src="'+L+'" alt="repaint"> repaint 的本质就是重新根据分层信息计算了绘制指令。</p><p>当改动了可见样式后，就需要重新计算，会引发 repaint。</p><p>由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。</p><h2 id="为什么-transform-的效率高" tabindex="-1">为什么 transform 的效率高 ？ <a class="header-anchor" href="#为什么-transform-的效率高" aria-label="Permalink to &quot;为什么 transform 的效率高 ？&quot;">​</a></h2><p><img src="'+M+'" alt="transform"><img src="'+C+'" alt="transform"> 因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段</p><p>由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。</p>',65),x=[T];function F(O,H,w,B,J,j){return t(),s("div",null,x)}const A=a(D,[["render",F]]);export{v as __pageData,A as default};
