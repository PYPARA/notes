import{_ as a,c as i,o as e,a4 as s}from"./chunks/framework.DhcZWzV3.js";const l="/notes/assets/浏览器进程.BuoBRnjh.png",t="/notes/assets/事件循环.DEJHypxQ.png",p="/notes/assets/异步.ByUHli9B.png",o="/notes/assets/队列.Cw1b9L3A.png",E=JSON.parse('{"title":"事件循环","description":"","frontmatter":{},"headers":[],"relativePath":"learn/Learn/事件循环/事件循环.md","filePath":"learn/Learn/事件循环/事件循环.md","lastUpdated":1675924431000}'),r={name:"learn/Learn/事件循环/事件循环.md"},n=s('<h1 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h1><h2 id="浏览器的进程模型" tabindex="-1">浏览器的进程模型 <a class="header-anchor" href="#浏览器的进程模型" aria-label="Permalink to &quot;浏览器的进程模型&quot;">​</a></h2><p>每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。</p><h2 id="线程" tabindex="-1">线程 <a class="header-anchor" href="#线程" aria-label="Permalink to &quot;线程&quot;">​</a></h2><p>一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。</p><p>如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。</p><h2 id="浏览器有哪些进程和线程" tabindex="-1">浏览器有哪些进程和线程 <a class="header-anchor" href="#浏览器有哪些进程和线程" aria-label="Permalink to &quot;浏览器有哪些进程和线程&quot;">​</a></h2><p>浏览器是一个多进程多线程的应用程序</p><p>浏览器内部工作极其复杂。</p><p>为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。</p><p>主要进程:</p><ol><li>浏览器进程 主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。</li><li>网络进程 负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。</li><li>渲染进程 渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、 JS 代码。 默认情况下，浏览器会为每个标签⻚开启一个新的渲染进程，以保证不同的标签⻚之间不相互影响。</li></ol><p><img src="'+l+'" alt="进程"></p><h2 id="渲染主线程是如何工作" tabindex="-1">渲染主线程是如何工作 <a class="header-anchor" href="#渲染主线程是如何工作" aria-label="Permalink to &quot;渲染主线程是如何工作&quot;">​</a></h2><p>渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于:</p><ul><li>解析 HTML</li><li>解析 CSS</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒把⻚面画 60 次</li><li>执行全局 JS 代码</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li><li>......</li></ul><p>要处理这么多的任务，主线程如何调度任务?</p><p>排队</p><ol><li>在最开始的时候，渲染主线程会进入一个无限循环</li><li>每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环;如果没有，则进入休眠状态。</li><li>其他所有线程(包括其他进程的线程)可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务</li></ol><p>这样一来，就可以让每个任务有条不紊的、持续的进行下去了。 整个过程，被称之为事件循环(消息循环)</p><p><img src="'+t+'" alt="事件循环"></p><h2 id="异步" tabindex="-1">异步 <a class="header-anchor" href="#异步" aria-label="Permalink to &quot;异步&quot;">​</a></h2><p>代码在执行过程中，会遇到一些无法立即处理的任务，比如:</p><ul><li>计时完成后需要执行的任务 -- <code>setTimeout</code>、<code>setInterval</code></li><li>网络通信完成后需要执行的任务 -- <code>XHR</code>、<code>Fetch</code></li><li>用户操作后需要执行的任务 -- <code>addEventListener</code></li></ul><p>使用异步解决，渲染主线程永不阻塞。</p><p><img src="'+p+'" alt="异步"></p><h2 id="任务优先级" tabindex="-1">任务优先级 <a class="header-anchor" href="#任务优先级" aria-label="Permalink to &quot;任务优先级&quot;">​</a></h2><p>任务没有优先级，在消息队列中先进先出</p><p>但消息队列是有优先级的</p><ul><li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。 在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。</li><li>浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行</li></ul><p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noreferrer">https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint</a></p><p>在目前 chrome 的实现中，至少包含了下面的队列:</p><ul><li>延时队列: 用于存放计时器到达后的回调任务，优先级「中」</li><li>交互队列: 用于存放用户操作后产生的事件处理任务，优先级「高」</li><li>微队列: 用户存放需要最快执行的任务，优先级「最高」</li></ul><p>添加任务到微队列的主要方式主要是使用 <code>Promise</code>、<code>MutationObserver</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 立即把一个函数添加到微队列</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">`函数`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p><img src="'+o+'" alt="队列"></p>',36),h=[n];function c(d,k,m,_,u,g){return e(),i("div",null,h)}const f=a(r,[["render",c]]);export{E as __pageData,f as default};
