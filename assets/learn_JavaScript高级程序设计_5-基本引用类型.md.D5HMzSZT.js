import{_ as i,c as s,o as a,a4 as l}from"./chunks/framework.DhcZWzV3.js";const y=JSON.parse('{"title":"基本引用类型","description":"","frontmatter":{},"headers":[],"relativePath":"learn/JavaScript高级程序设计/5-基本引用类型.md","filePath":"learn/JavaScript高级程序设计/5-基本引用类型.md","lastUpdated":1637807724000}'),t={name:"learn/JavaScript高级程序设计/5-基本引用类型.md"},n=l(`<h1 id="基本引用类型" tabindex="-1">基本引用类型 <a class="header-anchor" href="#基本引用类型" aria-label="Permalink to &quot;基本引用类型&quot;">​</a></h1><p>引用值(或者对象)是某个特定引用类型的实例。在 ECMAScript 中，引用类型是把数据和功能组 织到一起的结构。 引用类型有时候也 被称为对象定义，因为它们描述了自己的对象应有的属性和方法。</p><h2 id="date" tabindex="-1">Date <a class="header-anchor" href="#date" aria-label="Permalink to &quot;Date&quot;">​</a></h2><p>Date 类型将日期保存为自协调世界时(UTC，Universal Time Coordinated)时间 1970 年 1 月 1 日午夜(零时)至今所 经过的毫秒数。使用这种存储格式，Date 类型可以精确表示 1970 年 1 月 1 日之前及之后 285616 年的日期。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 构造函数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> now </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 字符串转换为表示该日期的毫秒数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 如果直接把表示日期的字 符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someDate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">parse</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;May 23, 2019&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> someDate </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;May 23, 2019&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Date.UTC()方法也返回日期的毫秒表示，但使用的是跟 Date.parse()不同的信息来生成这个值。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 传给 Date.UTC()的参数是年、零起点月数(1 月是 0，2 月是 1，以此类推)、日(1~31)、时(0~23)、 分、秒和毫秒。这些参数中，只有前两个(年和月)是必需的。如果不提供日，那么默认为 1 日。其他 参数的默认值都是 0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//  *** 月数是零起点</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// GMT时间2000年1月1日零点</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y2k </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UTC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// GMT时间2005年5月5日下午5点55分55秒</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> allFives </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Date</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Date.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UTC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2005</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">17</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Date.UTC()也会被 Date 构造函数隐式调用</span></span></code></pre></div><h3 id="继承的方法" tabindex="-1">继承的方法 <a class="header-anchor" href="#继承的方法" aria-label="Permalink to &quot;继承的方法&quot;">​</a></h3><p>Date 类型重写了 toLocaleString()、toString()和 valueOf()方法</p><p>toString()方法通常返回带时区信息的日期和时 间，而时间也是以 24 小时制(0~23)表示的 toLocaleString()方法返回与浏览器 运行的本地环境一致的日期和时间 Date 类型的 valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示</p><h3 id="日期格式化方法" tabindex="-1">日期格式化方法 <a class="header-anchor" href="#日期格式化方法" aria-label="Permalink to &quot;日期格式化方法&quot;">​</a></h3><ul><li>toDateString()显示日期中的周几、月、日、年(格式特定于实现);</li><li>toTimeString()显示日期中的时、分、秒和时区(格式特定于实现);</li><li>toLocaleDateString()显示日期中的周几、月、日、年(格式特定于实现和地区);</li><li>toLocaleTimeString()显示日期中的时、分、秒(格式特定于实现和地区);</li><li>toUTCString()显示完整的 UTC 日期(格式特定于实现)。</li></ul><h3 id="日期-时间组件方法" tabindex="-1">日期/时间组件方法 <a class="header-anchor" href="#日期-时间组件方法" aria-label="Permalink to &quot;日期/时间组件方法&quot;">​</a></h3><p>.</p><h2 id="regexp" tabindex="-1">RegExp <a class="header-anchor" href="#regexp" aria-label="Permalink to &quot;RegExp&quot;">​</a></h2><p>ECMAScript 通过 RegExp 类型支持正则表达式。正则表达式使用类似 Perl 的简洁语法来创建</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> expression </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pattern</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">flags;</span></span></code></pre></div><p>pattern(模式)可以是任何简单或复杂的正则表达式，包括字符类、限定符、 分组、向前查找和反向引用。 每个正则表达式可以带零个或多个 flags(标记)，用于控制正则表达式的行为</p><ul><li>g:全局模式，表示查找字符串的全部内容，而不是找到第一个匹配的内容就结束。  i:不区分大小写，表示在查找匹配时忽略 pattern 和字符串的大小写。</li><li>m:多行模式，表示查找到一行文本末尾时会继续查找。</li><li>y:粘附模式，表示只查找从 lastIndex 开始及之后的字符串。</li><li>u:Unicode 模式，启用 Unicode 匹配。</li><li>s:dotAll 模式，表示元字符.匹配任何字符(包括\\n 或\\r)。</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 匹配字符串中的所有&quot;at&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pattern1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pattern2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[bc]</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写 </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pattern3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">gi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//  元字符在模式中也必须转义</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( [ { \\ ^ $ | ) ] } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> . </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 匹配第一个&quot;bat&quot;或&quot;cat&quot;，忽略大小写 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let pattern1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[bc]</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 匹配第一个&quot;[bc]at&quot;，忽略大小写 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let pattern2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\[</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">bc</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\]</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">i</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 匹配所有以&quot;at&quot;结尾的三字符组合，忽略大小写 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let pattern3 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">gi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 匹配所有&quot;.at&quot;，忽略大小写 </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">let pattern4 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">at</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">gi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span></code></pre></div><h3 id="regexp-实例属性" tabindex="-1">RegExp 实例属性 <a class="header-anchor" href="#regexp-实例属性" aria-label="Permalink to &quot;RegExp 实例属性&quot;">​</a></h3><ul><li>global:布尔值，表示是否设置了 g 标记。</li><li>ignoreCase:布尔值，表示是否设置了 i 标记。</li><li>unicode:布尔值，表示是否设置了 u 标记。</li><li>sticky:布尔值，表示是否设置了 y 标记。</li><li>lastIndex:整数，表示在源字符串中下一次搜索的开始位置，始终从 0 开始。</li><li>multiline:布尔值，表示是否设置了 m 标记。</li><li>dotAll:布尔值，表示是否设置了 s 标记。</li><li>source:正则表达式的字面量字符串(不是传给构造函数的模式字符串)，没有开头和结尾的斜杠。</li><li>flags:正则表达式的标记字符串。始终以字面量而非传入构造函数的字符串模式形式返回(没有前后斜杠)。</li></ul><h3 id="regexp-实例方法" tabindex="-1">RegExp 实例方法 <a class="header-anchor" href="#regexp-实例方法" aria-label="Permalink to &quot;RegExp 实例方法&quot;">​</a></h3><p>RegExp 实例的主要方法是 exec()，主要用于配合捕获组使用。</p><p>正则表达式的另一个方法是 test()，接收一个字符串参数。如果输入的文本与模式匹配，则参数 返回 true，否则返回 false。</p><h3 id="regexp-构造函数属性" tabindex="-1">RegExp 构造函数属性 <a class="header-anchor" href="#regexp-构造函数属性" aria-label="Permalink to &quot;RegExp 构造函数属性&quot;">​</a></h3><h3 id="模式局限" tabindex="-1">模式局限 <a class="header-anchor" href="#模式局限" aria-label="Permalink to &quot;模式局限&quot;">​</a></h3><h2 id="原始值包装类型" tabindex="-1">原始值包装类型 <a class="header-anchor" href="#原始值包装类型" aria-label="Permalink to &quot;原始值包装类型&quot;">​</a></h2><p>ECMAScript 提供了 3 种特殊的引用类型:Boolean、Number 和 String。每当用 到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法。</p><h3 id="boolean" tabindex="-1">Boolean <a class="header-anchor" href="#boolean" aria-label="Permalink to &quot;Boolean&quot;">​</a></h3><p>Boolean 的实例会重写 valueOf()方法，返回一个原始值 true 或 false。toString()方法被调 用时也会被覆盖，返回字符串&quot;true&quot;或&quot;false&quot;。</p><p>所有对象在布 尔表达式中都会自动转换为 true, new Boolean(false)也不例外</p><h3 id="number" tabindex="-1">Number <a class="header-anchor" href="#number" aria-label="Permalink to &quot;Number&quot;">​</a></h3><p>与 Boolean 类型一样，Number 类型重写了 valueOf()、toLocaleString()和 toString()方 法。valueOf()方法返回 Number 对象表示的原始数值，另外两个方法返回数值字符串。toString() 方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串</p><h3 id="string" tabindex="-1">String <a class="header-anchor" href="#string" aria-label="Permalink to &quot;String&quot;">​</a></h3><p>String 对象的方法可以在所有字符串原始值上调用。3 个继承的方法 valueOf()、toLocaleString() 和 toString()都返回对象的原始字符串值。</p><h2 id="单例内置对象" tabindex="-1">单例内置对象 <a class="header-anchor" href="#单例内置对象" aria-label="Permalink to &quot;单例内置对象&quot;">​</a></h2><h3 id="global" tabindex="-1">Global <a class="header-anchor" href="#global" aria-label="Permalink to &quot;Global&quot;">​</a></h3><p>在全局作用域中定义的变量和函数都会变成 Global 对象的属性</p><h4 id="url-编码方法" tabindex="-1">URL 编码方法 <a class="header-anchor" href="#url-编码方法" aria-label="Permalink to &quot;URL 编码方法&quot;">​</a></h4><p>encodeURI()和 encodeURIComponent()方法用于编码统一资源标识符(URI)，以便传给浏览器。有效的 URI 不能包含某些字符，比如空格。</p><h4 id="eval-方法" tabindex="-1">eval() 方法 <a class="header-anchor" href="#eval-方法" aria-label="Permalink to &quot;eval() 方法&quot;">​</a></h4><p>这个方法就是一个完整的 ECMAScript 解释器，它接收一个参数，即一个要执行的 ECMAScript(JavaScript)字符串。</p><h4 id="global-对象属性" tabindex="-1">Global 对象属性 <a class="header-anchor" href="#global-对象属性" aria-label="Permalink to &quot;Global 对象属性&quot;">​</a></h4><ul><li>undefined</li><li>NaN</li><li>Infinity</li><li>Object</li><li>Array</li><li>Function</li><li>Boolean</li><li>String</li><li>Number</li><li>Date</li><li>RegExp</li><li>Symbol</li><li>Error</li><li>EvalError</li><li>RangeError</li><li>ReferenceError</li><li>SyntaxError</li><li>TypeError</li><li>URIError</li></ul><h4 id="window-对象" tabindex="-1">window 对象 <a class="header-anchor" href="#window-对象" aria-label="Permalink to &quot;window 对象&quot;">​</a></h4><p>虽然 ECMA-262 没有规定直接访问 Global 对象的方式，但浏览器将 window 对象实现为 Global 对象的代理。因此，所有全局作用域中声明的变量和函数都变成了 window 的属性。</p><h3 id="math" tabindex="-1">Math <a class="header-anchor" href="#math" aria-label="Permalink to &quot;Math&quot;">​</a></h3><p>ECMAScript 提供了 Math 对象作为保存数学公式、信息和计算的地方。Math 对象提供了一些辅助计算的属性和方法。</p><h2 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h2><p>JavaScript 中的对象称为引用值，几种内置的引用类型可用于创建特定类型的对象。</p><ul><li>引用值与传统面向对象编程语言中的类相似，但实现不同。</li><li>Date 类型提供关于日期和时间的信息，包括当前日期、时间及相关计算。</li><li>RegExp 类型是 ECMAScript 支持正则表达式的接口，提供了大多数基础的和部分高级的正则表达式功能。</li></ul><p>JavaScript 比较独特的一点是，函数实际上是 Function 类型的实例，也就是说函数也是对象。因为函数也是对象，所以函数也有方法，可以用于增强其能力。 由于原始值包装类型的存在，JavaScript 中的原始值可以被当成对象来使用。有 3 种原始值包装类 型:Boolean、Number 和 String。它们都具备如下特点。</p><ul><li>每种包装类型都映射到同名的原始类型。</li><li>以读模式访问原始值时，后台会实例化一个原始值包装类型的对象，借助这个对象可以操作相应的数据。</li><li>涉及原始值的语句执行完毕后，包装对象就会被销毁。</li></ul><p>当代码开始执行时，全局上下文中会存在两个内置对象:Global 和 Math。其中，Global 对象在 大多数 ECMAScript 实现中无法直接访问。不过，浏览器将其实现为 window 对象。所有全局变量和函 数都是 Global 对象的属性。Math 对象包含辅助完成复杂计算的属性和方法。</p>`,53),h=[n];function e(p,k,r,d,o,E){return a(),s("div",null,h)}const c=i(t,[["render",e]]);export{y as __pageData,c as default};
