import{_ as e,c as i,o as s,a4 as t}from"./chunks/framework.DhcZWzV3.js";const u=JSON.parse('{"title":"15 DOM扩展","description":"","frontmatter":{},"headers":[],"relativePath":"learn/JavaScript高级程序设计/15-DOM扩展.md","filePath":"learn/JavaScript高级程序设计/15-DOM扩展.md","lastUpdated":1656493248000}'),a={name:"learn/JavaScript高级程序设计/15-DOM扩展.md"},l=t(`<h1 id="_15-dom扩展" tabindex="-1">15 DOM扩展 <a class="header-anchor" href="#_15-dom扩展" aria-label="Permalink to &quot;15 DOM扩展&quot;">​</a></h1><ul><li>理解 Selectors API</li><li>使用 HTML5 DOM 扩展</li></ul><p>尽管 DOM API 已经相当不错，但仍然不断有标准或专有的扩展出现，以支持更多功能。2008 年以前，大部分浏览器对 DOM 的扩展是专有的。此后，W3C 开始着手将这些已成为事实标准的专有扩展编制成正式规范。</p><p>基于以上背景，诞生了描述 DOM 扩展的两个标准:Selectors API 与 HTML5。这两个标准体现了社区需求和标准化某些手段及 API 的愿景。另外还有较小的 Element Traversal 规范，增加了一些 DOM 属性。 专有扩展虽然还有，但这两个规范(特别是 HTML5)已经涵盖其中大部分。本章也会讨论专有扩展。</p><h2 id="_15-1-selectors-api" tabindex="-1">15.1 Selectors API <a class="header-anchor" href="#_15-1-selectors-api" aria-label="Permalink to &quot;15.1 Selectors API&quot;">​</a></h2><p>JavaScript 库中最流行的一种能力就是根据 CSS 选择符的模式匹配 DOM 元素。比如，jQuery 就完全 以 CSS 选择符查询 DOM 获取元素引用，而不是使用 getElementById()和 getElementsByTagName()。</p><p>Selectors API(参见 W3C 网站上的 Selectors API Level 1)是 W3C 推荐标准，规定了浏览器原生支 持的 CSS 查询 API。支持这一特性的所有 JavaScript 库都会实现一个基本的 CSS 解析器，然后使用已有 的 DOM 方法搜索文档并匹配目标节点。虽然库开发者在不断改进其性能，但 JavaScript 代码能做到的 毕竟有限。通过浏览器原生支持这个 API，解析和遍历 DOM 树可以通过底层编译语言实现，性能也有 了数量级的提升。</p><p>Selectors API Level 1 的核心是两个方法:<code>querySelector()</code>和 <code>querySelectorAll()</code>。在兼容浏 览器中，Document 类型和 Element 类型的实例上都会暴露这两个方法。</p><p>Selectors API Level 2 规范在 Element 类型上新增了更多方法，比如 <code>matches()</code>、<code>find()</code>和 <code>findAll()</code>。不过，目前还没有浏览器实现或宣称实现 <code>find()</code> 和 <code>findAll()</code>。</p><h3 id="_15-1-1-queryselector" tabindex="-1">15.1.1 querySelector() <a class="header-anchor" href="#_15-1-1-queryselector" aria-label="Permalink to &quot;15.1.1 querySelector()&quot;">​</a></h3><p><code>querySelector()</code> 方法接收 CSS 选择符参数，返回匹配该模式的第一个后代元素，如果没有匹配项则返回 <code>null</code>。</p><p>在 Document 上使用 <code>querySelector()</code> 方法时，会从文档元素开始搜索;在 Element 上使用 <code>querySelector()</code> 方法时，则只会从当前元素的后代中查询。</p><p>用于查询模式的 CSS 选择符可繁可简，依需求而定。如果选择符有语法错误或碰到不支持的选择符， 则 <code>querySelector()</code> 方法会抛出错误。</p><h3 id="_15-1-2-queryselectorall" tabindex="-1">15.1.2 querySelectorAll() <a class="header-anchor" href="#_15-1-2-queryselectorall" aria-label="Permalink to &quot;15.1.2 querySelectorAll()&quot;">​</a></h3><p><code>querySelectorAll()</code>方法跟 <code>querySelector()</code>一样，也接收一个用于查询的参数，但它会返回所有匹配的节点，而不止一个。这个方法返回的是一个 <code>NodeList</code> 的静态实例。</p><p><code>querySelectorAll()</code>返回的 <code>NodeList</code> 实例一个属性和方法都不缺，但它是一个静态的“快照”，而非“实时”的查询。这样的底层实现避免了使用 <code>NodeList</code> 对象可能造成的性 能问题。</p><p>以有效 CSS 选择符调用 <code>querySelectorAll()</code> 都会返回 <code>NodeList</code>，无论匹配多少个元素都可以。 如果没有匹配项，则返回空的 <code>NodeList</code> 实例。</p><p>与<code>querySelector()</code>一样，<code>querySelectorAll()</code>也可以在<code>Document</code>、<code>DocumentFragment</code>和 <code>Element</code> 类型上使用。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 取得 ID 为&quot;myDiv&quot;的&lt;div&gt;元素中的所有&lt;em&gt;元素</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ems </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;myDiv&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelectorAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;em&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 取得所有类名中包含&quot;selected&quot;的元素</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> selecteds </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelectorAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;.selected&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 取得所有是&lt;p&gt;元素子元素的&lt;strong&gt;元素</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strongs </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelectorAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;p strong&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>返回的 NodeList 对象可以通过 for-of 循环、item()方法或中括号语法取得个别元素。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strongElements </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">querySelectorAll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;p strong&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 以下 3 个循环的效果一样</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strong </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strongElements) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  strong.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;important&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strongElements.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  strongElements.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">item</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i).className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;important&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> strongElements.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  strongElements[i].className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;important&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>与 <code>querySelector()</code> 方法一样，如果选择符有语法错误或碰到不支持的选择符，则 <code>querySelector- All()</code> 方法会抛出错误。</p><h3 id="_15-1-3-matches" tabindex="-1">15.1.3 matches() <a class="header-anchor" href="#_15-1-3-matches" aria-label="Permalink to &quot;15.1.3 matches()&quot;">​</a></h3><p><code>matches()</code>方法(在规范草案中称为 <code>matchesSelector()</code>)接收一个 CSS 选择符参数，如果元素 匹配则该选择符返回 <code>true</code>，否则返回 <code>false</code>。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">matches</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;body.page1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>使用这个方法可以方便地检测某个元素会不会被 <code>querySelector()</code>或 <code>querySelectorAll()</code>方法返回。所有主流浏览器都支持 <code>matches()</code>。</p><h2 id="_15-2-元素遍历" tabindex="-1">15.2 元素遍历 <a class="header-anchor" href="#_15-2-元素遍历" aria-label="Permalink to &quot;15.2 元素遍历&quot;">​</a></h2><p>IE9 之前的版本不会把元素间的空格当成空白节点，而其他浏览器则会。这样就导致了 <code>childNodes</code> 和 <code>firstChild</code> 等属性上的差异。为了弥补这个差异，同时不影响 DOM 规范，W3C 通过新的 Element Traversal 规范定义了一组新属性。</p><p>Element Traversal API 为 DOM 元素添加了 5 个属性:</p><ul><li>childElementCount，返回子元素数量(不包含文本节点和注释);</li><li>firstElementChild，指向第一个 Element 类型的子元素(Element 版 firstChild);</li><li>lastElementChild，指向最后一个 Element 类型的子元素(Element 版 lastChild);</li><li>previousElementSibling，指向前一个 Element 类型的同胞元素 (Element 版 previousSibling);</li><li>nextElementSibling，指向后一个 Element 类型的同胞元素(Element 版 nextSibling)。</li></ul><h2 id="_15-3-html-5" tabindex="-1">15.3 HTML 5 <a class="header-anchor" href="#_15-3-html-5" aria-label="Permalink to &quot;15.3 HTML 5&quot;">​</a></h2><p>HTML5 代表着与以前的 HTML 截然不同的方向。在所有以前的 HTML 规范中，从未出现过描述 JavaScript 接口的情形，HTML 就是一个纯标记语言。JavaScript 绑定的事，一概交给 DOM 规范去定义。</p><p>然而，HTML5 规范却包含了与标记相关的大量 JavaScript API 定义。其中有的 API 与 DOM 重合， 定义了浏览器应该提供的 DOM 扩展。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>因为 HTML5 覆盖的范围极其广泛，所以本节主要讨论其影响所有 DOM 节点的部分。HTML5 的其他部分将在本书后面的相关章节中再讨论。</p></div><h3 id="_15-3-1-css-类扩展" tabindex="-1">15.3.1 CSS 类扩展 <a class="header-anchor" href="#_15-3-1-css-类扩展" aria-label="Permalink to &quot;15.3.1 CSS 类扩展&quot;">​</a></h3><p>自 HTML4 被广泛采用以来，Web 开发中一个主要的变化是 class 属性用得越来越多，其用处是为元素添加样式以及语义信息。自然地，JavaScript 与 CSS 类的交互就增多了，包括动态修改类名，以及根据给定的一个或一组类名查询元素，等等。为了适应开发者和他们对 class 属性的认可，HTML5 增加了一些特性以方便使用 CSS 类。</p><ol><li>getElementsByClassName()</li></ol><p><code>getElementsByClassName()</code>是 HTML5 新增的最受欢迎的一个方法，暴露在 document 对象和所有 HTML 元素上。 这个方法脱胎于基于原有 DOM 特性实现该功能的 JavaScript 库，提供了性能高好的原生实现。</p><p><code>getElementsByClassName()</code>方法接收一个参数，即包含一个或多个类名的字符串，返回类名中包含相应类的元素的 <code>NodeList</code>。如果提供了多个类名，则顺序无关紧要。</p><p>这个方法只会返回以调用它的对象为根元素的子树中所有匹配的元素。在 document 上调用 getElementsByClassName()返回文档中所有匹配的元素，而在特定元素上调用 getElementsByClassName()则返回该元素后代中匹配的元素。</p><p>如果要给包含特定类(而不是特定 ID 或标签)的元素添加事件处理程序，使用这个方法会很方便。 不过要记住，因为返回值是 NodeList，所以使用这个方法会遇到跟使用 getElementsByTagName()和其他返回 NodeList 对象的 DOM 方法同样的问题。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>与 <code>querySelectorAll()</code> 的一个区别是， <code>getElementsByClassName()</code> 在html内容改变时，已经获得的值会自动发生变化。而 <code>querySelectorAll()</code> 是一个静态的“快照”，而非“实时”的查询。</p></div><ol start="2"><li>classList 属性</li></ol><p>要操作类名，可以通过 <code>className</code> 属性实现添加、删除和替换。但 <code>className</code> 是一个字符串， 所以每次操作之后都需要重新设置这个值才能生效，即使只改动了部分字符串也一样。</p><p>HTML5 通过给所有元素增加 <code>classList</code> 属性为这些操作提供了更简单也更安全的实现方式。 <code>classList</code> 是一个新的集合类型 DOMTokenList 的实例。与其他 DOM 集合类型一样，DOMTokenList 也有 length 属性表示自己包含多少项，也可以通过 item() 或中括号取得个别的元素。此外，DOMTokenList 还增加了以下方法。</p><ul><li>add(value)，向类名列表中添加指定的字符串值 value。如果这个值已经存在，则什么也不做。</li><li>contains(value)，返回布尔值，表示给定的 value 是否存在。</li><li>remove(value)，从类名列表中删除指定的字符串值 value。</li><li>toggle(value)，如果类名列表中已经存在指定的 value，则删除;如果不存在，则添加。</li></ul><p>添加了 <code>classList</code> 属性之后，除非是完全删除或完全重写元素的 <code>class</code> 属性，否则 <code>className</code> 属性就用不到了。</p><h3 id="_15-3-2-焦点管理" tabindex="-1">15.3.2 焦点管理 <a class="header-anchor" href="#_15-3-2-焦点管理" aria-label="Permalink to &quot;15.3.2 焦点管理&quot;">​</a></h3><p>HTML5 增加了辅助 DOM 焦点管理的功能。首先是 <code>document.activeElement</code>，始终包含当前拥有焦点的 DOM 元素。页面加载时，可以通过用户输入(按 Tab 键或代码中使用 <code>focus()</code>方法)让某个元素自动获得焦点。</p><p>默认情况下，<code>document.activeElement</code> 在页面刚加载完之后会设置为 <code>document.body</code>。而在 页面完全加载之前，<code>document.activeElement</code> 的值为 <code>null</code>。</p><p>其次是 <code>document.hasFocus()</code> 方法，该方法返回布尔值，表示文档是否拥有焦点。</p><p>第一个方法可以用来查询文档，确定哪个元素拥有焦点，第二个方法可以查询文档是否获得了焦点， 而这对于保证 Web 应用程序的无障碍使用是非常重要的。</p><h3 id="_15-3-3-htmldocument扩展" tabindex="-1">15.3.3 HTMLDocument扩展 <a class="header-anchor" href="#_15-3-3-htmldocument扩展" aria-label="Permalink to &quot;15.3.3 HTMLDocument扩展&quot;">​</a></h3><p>HTML5 扩展了 HTMLDocument 类型，增加了更多功能。与其他 HTML5 定义的 DOM 扩展一样，这些变化同样基于所有浏览器事实上都已经支持的专有扩展。为此，即使这些扩展的标准化相对较晚，很多浏览器也早就实现了相应的功能。</p><ol><li>readyState 属性</li></ol><p>document.readyState 属性有三个可能的值:</p><ul><li>loading，表示文档正在加载;</li><li>complete，表示文档加载完成。</li><li>interactive 文档已被解析，&quot;正在加载&quot;状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载。</li></ul><ol start="2"><li>compatMode 属性</li></ol><p>指示浏览器当前处于什么渲染模式。</p><p>标准模式下 document.compatMode 的值是&quot;CSS1Compat&quot;，而在混杂模式下， document.compatMode 的值是&quot;BackCompat&quot;</p><ol start="3"><li>head 属性</li></ol><p>指向文档的<code>&lt;head&gt;</code>元素。</p><h3 id="_15-3-4-字符集属性" tabindex="-1">15.3.4 字符集属性 <a class="header-anchor" href="#_15-3-4-字符集属性" aria-label="Permalink to &quot;15.3.4 字符集属性&quot;">​</a></h3><p>HTML5 增加了几个与文档字符集有关的新属性。其中，<code>characterSet</code> 属性表示文档实际使用的字符集，也可以用来指定新字符集。这个属性的默认值是&quot;UTF-16&quot;，但可以通过<code>&lt;meta&gt;</code>元素或响应头，以及新增的 <code>characterSet</code> 属性来修改。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>MDN 上是 只读属性返回当前文档的字符编码。实际试试也是只读，并且默认值不确定。</p></div><h3 id="_15-3-5-自定义数据属性" tabindex="-1">15.3.5 自定义数据属性 <a class="header-anchor" href="#_15-3-5-自定义数据属性" aria-label="Permalink to &quot;15.3.5 自定义数据属性&quot;">​</a></h3><p>HTML5 允许给元素指定非标准的属性，但要使用前缀 <code>data-</code> 以便告诉浏览器，这些属性既不包含与渲染有关的信息，也不包含元素的语义信息。除了前缀，自定义属性对命名是没有限制的，<code>data-</code> 后面跟什么都可以。</p><p>定义了自定义数据属性后，可以通过元素的 <code>dataset</code> 属性来访问。<code>dataset</code> 属性是一个 <code>DOMStringMap</code> 的实例，包含一组键/值对映射。元素的每个 <code>data-name</code> 属性在 <code>dataset</code> 中都可以通过 <code>data-</code> 后面的字符串作为键来访问。</p><h3 id="_15-3-6-插入标记" tabindex="-1">15.3.6 插入标记 <a class="header-anchor" href="#_15-3-6-插入标记" aria-label="Permalink to &quot;15.3.6 插入标记&quot;">​</a></h3><p>DOM 虽然已经为操纵节点提供了很多 API，但向文档中一次性插入大量 HTML 时还是比较麻烦。 相比先创建一堆节点，再把它们以正确的顺序连接起来，直接插入一个 HTML 字符串要简单(快速) 得多。HTML5 已经通过以下 DOM 扩展将这种能力标准化了。</p><ol><li>innerHTML 属性</li></ol><p>在读取 innerHTML 属性时，会返回元素所有后代的 HTML 字符串，包括元素、注释和文本节点。 而在写入 innerHTML 时，则会根据提供的字符串值以新的 DOM 子树替代元素中原来包含的所有节点。</p><p>在写入模式下，赋给 innerHTML 属性的值会被解析为 DOM 子树，并替代元素之前的所有节点。 因为所赋的值默认为 HTML，所以其中的所有标签都会以浏览器处理 HTML 的方式转换为元素</p><ol start="2"><li>旧 IE 中的 innerHTML</li></ol><p>在所有现代浏览器中，通过 innerHTML 插入的<code>&lt;script&gt;</code>标签是不会执行的。而在 IE8 及之前的版 本中，只要这样插入的<code>&lt;script&gt;</code>元素指定了 defer 属性，且<code>&lt;script&gt;</code>之前是“受控元素”(scoped element)，那就是可以执行的。<code>&lt;script&gt;</code>元素与<code>&lt;style&gt;</code>或注释一样，都是“非受控元素”(NoScope element)，也就是在页面上看不到它们。IE 会把 innerHTML 中从非受控元素开始的内容都删掉，</p><ol start="3"><li>outerHTML 属性</li></ol><p>读取 <code>outerHTML</code> 属性时，会返回调用它的元素(及所有后代元素)的 HTML 字符串。在写入 <code>outerHTML</code> 属性时，调用它的元素会被传入的 HTML 字符串经解释之后生成的 DOM 子树取代。</p><ol start="4"><li>insertAdjacentHTML()与 insertAdjacentText()</li></ol><p>关于插入标签的最后两个新增方法是 <code>insertAdjacentHTML()</code> 和 <code>insertAdjacentText()</code>。这两 个方法最早源自 IE，它们都接收两个参数:要插入标记的位置和要插入的 HTML 或文本。</p><p>第一个参数必须是下列值中的一个:</p><ul><li>&quot;beforebegin&quot;，插入当前元素前面，作为前一个同胞节点;</li><li>&quot;afterbegin&quot;，插入当前元素内部，作为新的子节点或放在第一个子节点前面;</li><li>&quot;beforeend&quot;，插入当前元素内部，作为新的子节点或放在最后一个子节点后面;</li><li>&quot;afterend&quot;，插入当前元素后面，作为下一个同胞节点。</li></ul><p>注意这几个值是不区分大小写的。第二个参数会作为 HTML 字符串解析(与 <code>innerHTML</code> 和 <code>outerHTML</code> 相同)或者作为纯文本解析(与 <code>innerText</code> 和 <code>outerText</code> 相同)。如果是 HTML，则会在解析出错时抛出错误。</p><ol start="5"><li>内存与性能问题</li></ol><p>使用本节介绍的方法替换子节点可能在浏览器(特别是 IE)中导致内存问题。比如，如果被移除的子树元素中之前有关联的事件处理程序或其他 <code>JavaScript</code> 对象(作为元素的属性)，那它们之间的绑定关系会滞留在内存中。如果这种替换操作频繁发生，页面的内存占用就会持续攀升。在使用 <code>innerHTML</code>、 <code>outerHTML</code> 和 <code>insertAdjacentHTML()</code>之前，最好手动删除要被替换的元素上关联的事件处理程序和 <code>JavaScript</code> 对象。</p><p>使用这些属性当然有其方便之处，特别是 <code>innerHTML</code>。一般来讲，插入大量的新 <code>HTML</code> 使用 <code>innerHTML</code> 比使用多次 DOM 操作创建节点再插入来得更便捷。这是因为 HTML 解析器会解析设置给 <code>innerHTML</code>(或 <code>outerHTML</code>)的值。解析器在浏览器中是底层代码(通常是 C++代码)，比 <code>JavaScript</code> 快得多。不过，<code>HTML</code> 解析器的构建与解构也不是没有代价，因此最好限制使用 <code>innerHTML</code> 和 <code>outerHTML</code> 的次数。</p><ol start="6"><li>跨站点脚本</li></ol><p>尽管 <code>innerHTML</code> 不会执行自己创建的<code>&lt;script&gt;</code>标签，但仍然向恶意用户暴露了很大的攻击面，因 为通过它可以毫不费力地创建元素并执行 <code>onclick</code> 之类的属性。</p><p>如果页面中要使用用户提供的信息，则不建议使用 <code>innerHTML</code>。与使用 <code>innerHTML</code> 获得的方便相比，防止 XSS 攻击更让人头疼。</p><p>此时一定要隔离要插入的数据，在插入页面前必须毫不犹豫地使用相关的库对它们进行转义。</p><h3 id="_15-3-7-scrollintoview" tabindex="-1">15.3.7 scrollIntoView() <a class="header-anchor" href="#_15-3-7-scrollintoview" aria-label="Permalink to &quot;15.3.7 scrollIntoView()&quot;">​</a></h3><p>DOM 规范中没有涉及的一个问题是如何滚动页面中的某个区域。为填充这方面的缺失，不同浏览器实现了不同的控制滚动的方式。在所有这些专有方法中，HTML5 选择了标准化 <code>scrollIntoView()</code>。</p><p><code>scrollIntoView()</code>方法存在于所有 HTML 元素上，可以滚动浏览器窗口或容器元素以便包含元素进入视口。这个方法的参数如下:</p><ul><li>alignToTop 是一个布尔值。 <ul><li>true:窗口滚动后元素的顶部与视口顶部对齐。</li><li>false:窗口滚动后元素的底部与视口底部对齐。</li></ul></li><li>scrollIntoViewOptions 是一个选项对象。 <ul><li>behavior:定义过渡动画，可取的值为&quot;smooth&quot;和&quot;auto&quot;，默认为&quot;auto&quot;。</li><li>block:定义垂直方向的对齐，可取的值为&quot;start&quot;、&quot;center&quot;、&quot;end&quot;和&quot;nearest&quot;，默认为 &quot;start&quot;。</li><li>inline:定义水平方向的对齐，可取的值为&quot;start&quot;、&quot;center&quot;、&quot;end&quot;和&quot;nearest&quot;，默认为 &quot;nearest&quot;。</li></ul></li><li>不传参数等同于 alignToTop 为 true。</li></ul><p>这个方法可以用来在页面上发生某个事件时引起用户关注。把焦点设置到一个元素上也会导致浏览器将元素滚动到可见位置。</p><h2 id="_15-4-专有扩展" tabindex="-1">15.4 专有扩展 <a class="header-anchor" href="#_15-4-专有扩展" aria-label="Permalink to &quot;15.4 专有扩展&quot;">​</a></h2><p>尽管所有浏览器厂商都理解遵循标准的重要性，但它们也都有为弥补功能缺失而为 DOM 添加专有扩展的历史。虽然这表面上看是一件坏事，但专有扩展也为开发者提供了很多重要功能，而这些功能后来则有可能被标准化，比如进入 HTML5。</p><p>除了已经标准化的，各家浏览器还有很多未被标准化的专有扩展。这并不意味着它们将来不会被纳入标准，只不过在本书编写时，它们还只是由部分浏览器专有和采用。</p><h3 id="_15-4-1-children-属性" tabindex="-1">15.4.1 children 属性 <a class="header-anchor" href="#_15-4-1-children-属性" aria-label="Permalink to &quot;15.4.1 children 属性&quot;">​</a></h3><p>IE9 之前的版本与其他浏览器在处理空白文本节点上的差异导致了 children 属性的出现。children 属性是一个 HTMLCollection，只包含元素的 Element 类型的子节点。如果元素的子节点类型全部是元素类型，那 children 和 childNodes 中包含的节点应该是一样的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> childCount </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.children.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> firstChild </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> element.children[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">];</span></span></code></pre></div><h3 id="_15-4-2-contains-方法" tabindex="-1">15.4.2 contains() 方法 <a class="header-anchor" href="#_15-4-2-contains-方法" aria-label="Permalink to &quot;15.4.2 contains() 方法&quot;">​</a></h3><p>DOM 编程中经常需要确定一个元素是不是另一个元素的后代。IE 首先引入了 <code>contains()</code> 方法，让开发者可以在不遍历 DOM 的情况下获取这个信息。 <code>contains()</code> 方法应该在要搜索的祖先元素上调用，参数是待确定的目标节点。</p><p>如果目标节点是被搜索节点的后代，<code>contains()</code> 返回 <code>true</code>，否则返回 <code>false</code>。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.documentElement.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">contains</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(document.body)); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre></div><p>另外，使用 DOM Level 3 的 <code>compareDocumentPosition()</code> 方法也可以确定节点间的关系。</p><h3 id="_15-4-3-插入标记" tabindex="-1">15.4.3 插入标记 <a class="header-anchor" href="#_15-4-3-插入标记" aria-label="Permalink to &quot;15.4.3 插入标记&quot;">​</a></h3><p>HTML5 将 IE 发明的 <code>innerHTML</code> 和 <code>outerHTML</code> 纳入了标准，但还有两个属性没有入选。这两个剩下的属性是 <code>innerText</code> 和 <code>outerText</code>。</p><ol><li>innerText 属性</li></ol><p><code>innerText</code> 属性对应元素中包含的所有文本内容，无论文本在子树中哪个层级。在用于读取值时，<code>innerText</code> 会按照深度优先的顺序将子树中所有文本节点的值拼接起来。在用于写入值时，<code>innerText</code> 会移除元素的所有后代并插入一个包含该值的文本节点。</p><p>注意不同浏览器对待空格的方式不同，因此格式化之后的字符串可能包含也可能不包含原始 HTML 代码中的缩进。</p><p>设置 <code>innerText</code> 会移除元素之前所有的后代节点，完全改变 DOM 子树。此外，设置 innerText 也会编码出现在字符串中的 HTML 语法字符(小于号、大于号、引号及和号)。</p><p>因为设置 <code>innerText</code> 只能在容器元素中生成一个文本节点，所以为了保证一定是文本节点，就必 须进行 HTML 编码。innerText 属性可以用于去除 HTML 标签。通过将 <code>innerText</code> 设置为等于 <code>innerText</code>，可以去除所有 HTML 标签而只剩文本。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Firefox45(2016年3月发布)以前的版本中只支持<code>textContent</code>属性，与<code>innerText</code> 的区别是返回的文本中也会返回行内样式或脚本代码。<code>innerText</code> 目前已经得到所有浏览器支持，应该作为取得和设置文本内容的首选方法使用。</p></div><ol start="2"><li>outerText 属性</li></ol><p><code>outerText</code> 与 <code>innerText</code> 是类似的，只不过作用范围包含调用它的节点。要读取文本值时，<code>outerText</code> 与 <code>innerText</code> 实际上会返回同样的内容。但在写入文本值时，<code>outerText</code> 就大不相同了。 写入文本值时，<code>outerText</code> 不止会移除所有后代节点，而是会替换整个元素。</p><p>本质上，这相当于用新的文本节点替代 <code>outerText</code> 所在的元素。此时，原来的元素会与文档脱离关系，因此也无法访问。</p><p><code>outerText</code> 是一个非标准的属性，而且也没有被标准化的前景。因此，不推荐依赖这个属性实现重要的操作。除 Firefox 之外所有主流浏览器都支持 <code>outerText</code>。</p><h3 id="_15-4-4-滚动" tabindex="-1">15.4.4 滚动 <a class="header-anchor" href="#_15-4-4-滚动" aria-label="Permalink to &quot;15.4.4 滚动&quot;">​</a></h3><p>滚动是 HTML5 之前 DOM 标准没有涉及的领域。虽然 HTML5 把 <code>scrollIntoView()</code> 标准化了，但不同浏览器中仍然有其他专有方法。比如，<code>scrollIntoViewIfNeeded()</code> 作为 HTMLElement 类型的扩展可以在所有元素上调用。<code>scrollIntoViewIfNeeded(alingCenter)</code> 会在元素不可见的情况下，将其滚动到窗口或包含窗口中，使其可见;如果已经在视口中可见，则这个方法什么也不做。如果将可选的参数 <code>alingCenter</code> 设置为 true，则浏览器会尝试将其放在视口中央。Safari、 Chrome 和 Opera 实现了这个方法。</p><p>考虑到 <code>scrollIntoView()</code> 是唯一一个所有浏览器都支持的方法，所以只用它就可以了。</p><h2 id="_15-5-小结" tabindex="-1">15.5 小结 <a class="header-anchor" href="#_15-5-小结" aria-label="Permalink to &quot;15.5 小结&quot;">​</a></h2><p>虽然 DOM 规定了与 XML 和 HTML 文档交互的核心 API，但其他几个规范也定义了对 DOM 的扩展。很多扩展都基于之前的已成为事实标准的专有特性标准化而来。本章主要介绍了以下 3 个规范。</p><ul><li>Selectors API 为基于 CSS 选择符获取 DOM 元素定义了几个方法:<code>querySelector()</code>、 <code>querySelectorAll()</code> 和 <code>matches()</code>。</li><li>Element Traversal 在 DOM 元素上定义了额外的属性，以方便对 DOM 元素进行遍历。这个需求是因浏览器处理元素间空格的差异而产生的。</li><li>HTML5 为标准 DOM 提供了大量扩展。其中包括对 <code>innerHTML</code> 属性等事实标准进行了标准化， 还有焦点管理、字符集、滚动等特性。</li></ul><p>DOM 扩展的数量总体还不大，但随着 Web 技术的发展一定会越来越多。浏览器仍然没有停止对专有扩展的探索，如果出现成功的扩展，那么就可能成为事实标准，或者最终被整合到未来的标准中。</p>`,124),o=[l];function n(d,c,p,h,r,k){return s(),i("div",null,o)}const g=e(a,[["render",n]]);export{u as __pageData,g as default};
