# 语言基础

## 语法

### 区分大小写、标识符、注释
驼峰大小写
- 第一个字符必须是一个字母、下划线(_)或美元符号($);
- 剩下的其他字符可以是字母、下划线、美元符号或数字。
```js
// 单行注释
/* 这是多行
注释 */

```

### 严格模式
要对 整个脚本启用严格模式，在脚本开头加上这一行
```js
"use strict";
```
也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可:
```js
function doSomething() { 
  "use strict";
  // 函数体
}
```

### 语句
ECMAScript 中的语句以分号结尾。省略分号意味着由解析器确定语句在哪里结尾
代码块由一个左花括号({)标识开始，一个右 花括号(})标识结束

## 关键字与保留字
保留的关键字不能用作标识符或属性名

break       do          in            typeof
case        else        instanceof    var
catch       export      new           void
class       extends     return        while
const       finally     super         with
continue    for         switch        yield
debugger    function    this
default     if          throw
delete      import      try

规范中也描述了一组未来的保留字，同样不能用作标识符或属性名
以下是 ECMA-262 第 6 版为将来保留的所有词汇：

始终保留:
enum
严格模式下保留:
implements  package     public
interface   protected   static
let         private
模块代码中保留: 
await

## 变量
ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一 个用于保存任意值的命名占位符。有 3 个关键字可以声明变量:var、const 和 let。其中，var 在 ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。
### var
- 使用 var 操作符定义的变量会成为包含它的函数的局部变量
- 在函数内定义变量时省 略 var 操作符，可以创建一个全局变量,但不推荐这么做
- 如果需要定义多个变量，可以在一条语句中用逗号分隔每个变量
```js
var message = "hi",
    found = false,
    age = 29;
```
- 在严格模式下，不能定义名为 eval 和 arguments 的变量，否则会导致语法错误

#### var 声明提升
使用这个关键字声明的变量会自动提升到函数作用域顶部
```js
function foo() {
  console.log(age);
  var age = 26;
}
foo();  // undefined
```
ECMAScript 运行时把它看成等价于如下代码：
```js

function foo() {
  var age;
  console.log(age);
  age = 26; 
}
foo();  // undefined
```
这就是所谓的“提升”(hoist),也就是把所有变量声明都拉到函数作用域的顶部.

### let
let 声明的范围是块作用域， 而 var 声明的范围是函数作用域
```js
if (true) { 
  var name = 'Matt';
  console.log(name); // Matt
}
console.log(name);   // Matt

if (true) {
  let age = 26;
  console.log(age);
}
console.log(age); // ReferenceError: age 没有定义
```
在这里，age 变量之所以不能在 if 块外部被引用，是因为它的作用域仅限于该块内部。块作用域 是函数作用域的子集，因此适用于 var 的作用域限制同样也适用于 let。

```js
// let 不允许同一个块作用域中出现冗余声明
var name;
var name;
let age;
let age; //SyntaxError;标识符age已经声明过了

// JavaScript 引擎会记录用于变量声明的标识符及其所在的块作用域，因此嵌套使用相同的标 识符不会报错，而这是因为同一个块中没有重复声明
var name = 'Nicholas';
console.log(name);    // 'Nicholas'
if (true) {
  var name = 'Matt';
  console.log(name);  // 'Matt'
}
let age = 30;
console.log(age);    // 30
if (true) {
  let age = 26;
  console.log(age);  // 26
}

// 对声明冗余报错不会因混用 let 和 var 而受影响
var name;
let name; // SyntaxError
let age;
var age; // SyntaxError
```
#### 暂时性死区 全局声明
```js
let 与 var 的另一个重要的区别，就是 let 声明的变量不会在作用域中被提升
// name 会被提升 
console.log(name); // undefined 
var name = 'Matt';
// age 不会被提升
console.log(age); // ReferenceError:age 没有定义 
let age = 26;

// 在解析代码时，JavaScript 引擎也会注意出现在块后面的 let 声明，只不过在此之前不能以任何方 式来引用未声明的变量。在 let 声明之前的执行瞬间被称为“暂时性死区”(temporal dead zone)，在此 阶段引用任何后面才声明的变量都会抛出 ReferenceError

// 与 var 关键字不同，使用 let 在全局作用域中声明的变量不会成为 window 对象的属性(var 声 明的变量则会)。
var name = 'Matt';
console.log(window.name); // 'Matt'
let age = 26;
console.log(window.age);  // undefined

// 不过，let 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续。因此，为了 避免 SyntaxError，必须确保页面不会重复声明同一个变量。

// 对于 let 这个新的 ES6 声明关键字，不能依赖条件声明模式。


// 在 let 出现之前，for 循环定义的迭代变量会渗透到循环体外部
// 而在使用 let 声明迭代变量时,JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量,这种每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括 for-in 和 for-of 循环

```

### const
const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且 尝试修改 const 声明的变量会导致运行时错误。

### 声明风格及最佳实践
不使用 var、const 优先，let 次之

## 数据类型
简单数据类型：
- Undefined
- Null
- Boolean
- Number
- String
- Symbol

复杂数据类型：
- Object

### typeof
- "undefined"表示值未定义;
- "boolean"表示值为布尔值;
- "string"表示值为字符串;
- "number"表示值为数值;
- "object"表示值为对象(而不是函数)或 null; 
- "function"表示值为函数;
- "symbol"表示值为符号。

用 typeof null 返回的是"object"。这是因为特殊值 null 被认为是一个对空对象的引用

### Undefined类型、Null类型
Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始 化时，就相当于给变量赋予了 undefined 值

Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回"object"的原因。
任何时候，只要变量要保存对象，而当时又没有那个 对象可保存，就要用 null 来填充该变量。这样就可以保持 null 是空对象指针的语义，并进一步将其 与 undefined 区分开来。

### Boolean类型
由于存在转换为等价的布尔值自动转换，理解流控制语句中使用的是什么变量就非常重要。 错误地使用对象而不是布尔值会明显改变应用程序的执行流。

### Number类型
Number 类型使用 IEEE 754 格式表示整 数和浮点值(在某些语言中也叫双精度值)。不同的数值类型相应地也有不同的数值字面量格式。

#### 八进制
整数也可以用八进制(以 8 为基数)或十六进制(以 16 为基数)字面量表示。对于八进制字面量， 第一个数字必须是零(0)，然后是相应的八进制数字(数值 0~7)。如果字面量中包含的数字超出了应 有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数
八进制字面量在严格模式下是无效的，会导致 JavaScript 引擎抛出语法错误。
```js
let octalNum1 = 070; // 八进制的56 
let octalNum2 = 079; //无效的八进制值，当成79处理
let octalNum3 = 08; // 无效的八进制值，当成 8 处理

```

#### 十六进制
要创建十六进制字面量，必须让真正的数值前缀 0x(区分大小写)，然后是十六进制数字(0~9 以 及 A~F)。十六进制数字中的字母大小写均可。
```js
let hexNum1 = 0xA; // 十六进制10 
let hexNum2 = 0x1f; // 十六进制31
```

#### 浮点值
要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字

因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为 整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0(如 1.0)，那它也会被转换为整数.

#### 值的范围
由于内存的限制，ECMAScript 并不支持表示这个世界上的所有数值。ECMAScript 可以表示的最小 数值保存在 Number.MIN_VALUE 中，这个值在多数浏览器中是 5e-324;可以表示的最大数值保存在 Number.MAX_VALUE 中，这个值在多数浏览器中是 1.797 693 134 862 315 7e+308。
任何无法表示的负数以-Infinity(负无穷大)表示，任何无法表示的正数以 Infinity(正无穷大)表示。

#### NaN
有一个特殊的数值叫 NaN，意思是“不是数值”(Not a Number)，用于表示本来要返回数值的操作失败了(而不是抛出错误)。

任何涉及 NaN 的操作始终返回 NaN
NaN 不等于包括 NaN 在内的任何值
把一个值传给 isNaN()后，该函数会尝试把它转换为数值,任何不能转换为数值的值都会导致这个函数返回 true。
```js
console.log(isNaN(NaN)); // true
console.log(isNaN(10)); // false，10 是数值
console.log(isNaN("10")); // false，可以转换为数值10 
console.log(isNaN("blue")); // true，不可以转换为数值 
console.log(isNaN(true)); // false，可以转换为数值1

isNaN([]) //false
isNaN({}) //true
```


#### 数字转换

- Number()函数
  - 布尔值，true 转换为 1，false 转换为 0。 
  - 数值，直接返回。
  - null，返回 0。
  - undefined，返回 NaN。
  - 字符串，应用以下规则。
    - 如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。 因此，Number("1")返回 1，Number("123")返回 123，Number("011")返回 11(忽略前面 的零)。
    - 如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值(同样，忽略前面的零)。
    - 如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整
    数值。
    - 如果是空字符串(不包含字符)，则返回 0。
    - 如果字符串包含除上述情况之外的其他字符，则返回 NaN。
  - 对象，调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。

一元加操作符与Number()函数遵循相同的转换规则

- parseInt()函数
  - 更专注于字符串是否包含数值模式。字符串最前面的空格会被 忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即 返回 NaN。这意味着空字符串也会返回 NaN(这一点跟 Number()不一样，它返回 0)。如果第一个字符 是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。
  - parseInt()也接收第二个参数，用于指定底数(进制数)
  - 因为不传底数参数相当于让 parseInt()自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。

- parseFloat()函数
  - 始终忽略字符串开头的零
  - 只解析十进制值，因此不能指定底数
  - 如果字符串表示整数(没有小数点或者小 数点后面只有一个零)，则 parseFloat()返回整数

  ### String类型
  