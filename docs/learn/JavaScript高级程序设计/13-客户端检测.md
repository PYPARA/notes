# 13 客户端检测
- 使用能力检测
- 用户代理检测的历史 
- 软件与硬件检测
- 检测策略


现实当中，浏览器之间的差异和莫名其妙的行为，让客户端检测变成一 种补救措施，而且也成为了开发策略的重要一环。如今，浏览器之间的差异相对 IE 大溃败以前已经好很多了，但浏览器间的不一致性依旧是 Web 开发中的常见主题。

要检测当前的浏览器有很多方法，每一种都有各自的长处和不足。问题的关键在于知道客户端检测 应该是解决问题的最后一个举措。任何时候，只要有更普适的方案可选，都应该毫不犹豫地选择。首先 要设计最常用的方案，然后再考虑为特定的浏览器进行补救。

## 13.1 能力检测
能力检测(又称特性检测)即在 JavaScript 运行时中使用一套简单的检测逻辑，测试浏览器是否支 持某种特性。这种方式不要求事先知道特定浏览器的信息，只需检测自己关心的能力是否存在即可。

能力检测的关键是理解两个重要概念。首先，如前所述，应该先检测最常用的方式。在前面的例子 中就是先检测 document.getElementById()再检测 document.all。测试最常用的方案可以优化代 码执行，这是因为在多数情况下都可以避免无谓检测。

### 13.1.1 安全能力检测
能力检测最有效的场景是检测能力是否存在的同时，验证其是否能够展现出预期的行为。 
要深入了解JavaScript能力检测，推荐阅读PeterMichaux的文章“FeatureDetection— State of the Art Browser Scripting”。

### 13.1.2 基于能力检测进行浏览器分析

虽然可能有人觉得能力检测类似于黑科技，但恰当地使用能力检测可以精准地分析运行代码的浏览 器。使用能力检测而非用户代理检测的优点在于，伪造用户代理字符串很简单，而伪造能够欺骗能力检测的浏览器特性却很难。

#### 1. 检测特性

可以按照能力将浏览器归类。如果你的应用程序需要使用特定的浏览器能力，那么最好集中检测所有能力，而不是等到用的时候再重复检测。
```js
// 检测浏览器是否支持 Netscape 式的插件
let hasNSPlugins = !!(navigator.plugins && navigator.plugins.length);
// 检测浏览器是否具有 DOM Level 1 能力
let hasDOM1 = !!(document.getElementById && document.createElement && document.getElementsByTagName);
```
这个例子完成了两项检测:一项是确定浏览器是否支持 Netscape 式的插件，另一项是检测浏览器 是否具有 DOM Level 1 能力。保存在变量中的布尔值可以用在后面的条件语句中，这样比重复检测省事多了。

#### 2. 检测浏览器

可以根据对浏览器特性的检测并与已知特性对比，确认用户使用的是什么浏览器。这样可以获得比 用户代码嗅探(稍后讨论)更准确的结果。但未来的浏览器版本可能不适用于这套方案。

下面来看一个例子，根据不同浏览器独有的行为推断出浏览器的身份。这里故意没有使用 `navigator.userAgent` 属性。
```js
class BrowserDetector {
  constructor() {
    // 测试条件编译
    // IE6~10 支持
    this.isIE_Gte6Lte10 = /*@cc_on!@*/false;
    // 测试documentMode
    // IE7~11 支持
    this.isIE_Gte7Lte11 = !!document.documentMode;
    // 测试 StyleMedia 构造函数
    // Edge 20 及以上版本支持 
    this.isEdge_Gte20 = !!window.StyleMedia;
    // 测试Firefox专有扩展安装API
    // 所有版本的 Firefox 都支持
    this.isFirefox_Gte1 = typeof InstallTrigger !== 'undefined';
    // 测试 chrome 对象及其 webstore 属性
    // Opera的某些版本有window.chrome，但没有window.chrome.webstore
    // 所有版本的 Chrome 都支持
    this.isChrome_Gte1 = !!window.chrome && !!window.chrome.webstore;
    // Safari 早期版本会给构造函数的标签符追加"Constructor"字样，如:
    // window.Element.toString(); // [object ElementConstructor]
    // Safari 3~9.1 支持
    this.isSafari_Gte3Lte9_1 = /constructor/i.test(window.Element);

    // 推送通知 API 暴露在 window 对象上
    // 使用默认参数值以避免对undefined调用toString() 
    // Safari 7.1 及以上版本支持 
    this.isSafari_Gte7_1 =
      (({pushNotification = {}} = {}) =>
      pushNotification.toString() == '[object SafariRemoteNotification]'
      )(window.safari);

    // 测试 addons 属性
    // Opera 20 及以上版本支持
    this.isOpera_Gte20 = !!window.opr && !!window.opr.addons;
  }
  isIE() { return this.isIE_Gte6Lte10 || this.isIE_Gte7Lte11; }
  isEdge() { return this.isEdge_Gte20 && !this.isIE(); }
  isFirefox() { return this.isFirefox_Gte1; }
  isChrome() { return this.isChrome_Gte1; }
  isSafari() { return this.isSafari_Gte3Lte9_1 || this.isSafari_Gte7_1; }
  isOpera() { return this.isOpera_Gte20; }
}
```
这个类暴露的通用浏览器检测方法使用了检测浏览器范围的能力测试。随着浏览器的变迁及发展， 可以不断调整底层检测逻辑，但主要的 API 可以保持不变。

#### 3. 能力检测的局限

通过检测一种或一组能力，并不总能确定使用的是哪种浏览器。以下“浏览器检测”代码(或其他 类似代码)经常出现在很多网站中，但都没有正确使用能力检测。

```js
// 不要这样做!不够特殊
let isFirefox = !!(navigator.vendor && navigator.vendorSub);
// 不要这样做!假设太多
let isIE = !!(document.all && document.uniqueID);
```

这是错误使用能力检测的典型示例。过去，Firefox 可以通过 `navigator.vendor` 和 `navigator.vendorSub` 来检测，但后来 Safari 也实现了同样的属性，于是这段代码就会产生误报。为确定 IE，
这段代码检测了 document.all 和 document.uniqueID。这是假设 IE 将来的版本中还会继续存在这 两个属性，而且其他浏览器也不会实现它们。不过这两个检测都使用双重否定操作符来产生布尔值（这样可以生成便于存储和访问的结果)。

::: tip
能力检测最适合用于决定下一步该怎么做，而不一定能够作为辨识浏览器的标志。
:::

## 13.2 用户代理检测
用户代理检测通过浏览器的用户代理字符串确定使用的是什么浏览器。用户代理字符串包含在每个 HTTP 请求的头部，在 JavaScript 中可以通过 navigator.userAgent 访问。在服务器端，常见的做法是根据接收到的用户代理字符串确定浏览器并执行相应操作。而在客户端，用户代理检测被认为是不可靠的，只应该在没有其他选项时再考虑。
用户代理字符串最受争议的地方就是，在很长一段时间里，浏览器都通过在用户代理字符串包含 错误或误导性信息来欺骗服务器。要理解背后的原因，必须回顾一下自 Web 出现之后用户代理字符串的历史。

### 13.2.1 用户代理的历史
HTTP 规范(1.0 和 1.1)要求浏览器应该向服务器发送包含浏览器名称和版本信息的简短字符串。RFC 2616(HTTP 1.1)是这样描述用户代理字符串的:

产品标记用于通过软件名称和版本来标识通信产品的身份。多数使用产品标记的字段也允许列出属于应用主要部分的子产品，以空格分隔。按照约定，产品按照标识应用重要程度的先后顺序列出。

这个规范进一步要求用户代理字符串应该是“标记/版本”形式的产品列表。但现实当中的用户代理字符串远没有那么简单。

1. 早期浏览器

美国国家超级计算应用中心(NCSA，National Center for Supercomputing Applications)发布于 1993 年的 Mosaic 是早期 Web 浏览器的代表，其用户代理字符串相当简单，类似于:
`Mosaic/0.9`

斜杠前是产品名称，斜杠前是产品名称。

在网景公司准备开发浏览器时，代号确定为“Mozilla”(Mosaic Killer 的简写)。第一个公开发行版 Netscape Navigator 2 的用户代理字符串是这样的: `Mozilla/Version [Language] (Platform; Encryption)`

网景公司遵守了将产品名称和版本作为用户代理字符串的规定，但又在后面添加了如下信息。
- Language:语言代码，表示浏览器的目标使用语言。
- Platform:表示浏览器所在的操作系统和/或平台。
- Encryption:包含的安全加密类型，可能的值是 U(128 位加密)、I(40 位加密)和 N(无加密)。