# 集合引用类型

## Object
显式地创建 Object 的实例有两种方式。
第一种是使用 new 操作符和 Object 构造函数
另一种方式是使用对象字面量(object literal)表示法。

```js
let person = new Object();
person.name = "Nicholas";
person.age = 29;

let person = {
  name: "Nicholas",
  age: 29
};
```

** 在使用对象字面量表示法定义对象时，并不会实际调用Object构造函数。

## Array
ECMAScript 数组也是一组有序的数据，但跟其他语言 不同的是，数组中每个槽位可以存储任意类型的数据
ECMAScript 数组也是动态大小的，会随着数据添加而 自动增长

### 创建数组
有几种基本的方式可以创建数组。

- 一种是使用 Array 构造函数,在使用 Array 构造函数时，也可以省略 new 操作符
- 另一种创建数组的方式是使用数组字面量(array literal)表示法


** 与对象一样，在使用数组字面量表示法创建数组不会调用Array构造函数

ES6 新增的用于创建数组的两种静态方法,from()和 of()
from()用于将 类数组结构转换为数组实例，
而 of()用于将一组参数转换为数组实例。


Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个 length 属性 和可索引元素的结构。

```js
// 字符串会被拆分为单字符数组 
console.log(Array.from("Matt")); // ["M", "a", "t", "t"]
// 可以使用from()将集合和映射转换为一个新数组 
const m = new Map().set(1, 2)
                   .set(3, 4);
const s = new Set().add(1)
                   .add(2)
                   .add(3)
                   .add(4);
console.log(Array.from(m)); // [[1, 2], [3, 4]]
console.log(Array.from(s)); // [1, 2, 3, 4]

  // Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4];
const a2 = Array.from(a1);
console.log(a1);        // [1, 2, 3, 4]
alert(a1 === a2); // false

// 可以使用任何可迭代对象 
const iter = {
  *[Symbol.iterator]() {
    yield 1;
    yield 2;
    yield 3;
    yield 4;
  } 
};
console.log(Array.from(iter)); // [1, 2, 3, 4]

// arguments 对象可以被轻松地转换为数组 
function getArgsArray() {
  return Array.from(arguments);
}
console.log(getArgsArray(1, 2, 3, 4)); // [1, 2, 3, 4]
// from()也能转换带有必要属性的自定义对象 
const arrayLikeObject = {
  0: 1,
  1: 2,
  2: 3,
  3: 4,
  length: 4
};
console.log(Array.from(arrayLikeObject)); // [1, 2, 3, 4]
```

Array.from()还接收第二个可选的映射函数参数。这个函数可以直接增强新数组的值，而无须像 调用 Array.from().map()那样先创建一个中间数组。还可以接收第三个可选参数，用于指定映射函 数中 this 的值。但这个重写的 this 值在箭头函数中不适用。

```js
const a1 = [1, 2, 3, 4];
const a2 = Array.from(a1, x => x**2);
const a3 = Array.from(a1, function(x) {return x**this.exponent}, {exponent: 2}); 
console.log(a2); // [1, 4, 9, 16]
console.log(a3); // [1, 4, 9, 16]

```

Array.of()可以把一组参数转换为数组。这个方法用于替代在 ES6 之前常用的 Array.prototype.slice.call(arguments)，一种异常笨拙的将 arguments 对象转换为数组的写法

```js
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]
console.log(Array.of(undefined));  // [undefined]

// 
if (!Array.of) {
  Array.of = function() {
    return Array.prototype.slice.call(arguments);
  };
}
```

### 数组空位
使用数组字面量初始化数组时，可以使用一串逗号来创建空位(hole)。ECMAScript 会将逗号之间 相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位。

由于行为不一致和存在性能隐患，因此实践中要避免使用数组空位。如果确实需要 空位，则可以显式地用 undefined 值代替。

### 数组索引
如果索引小于数组包含的元素数，则返回存储在相应位置的元素
如果把一个值设置给超过数组最大索引的索引，则数组长度会自动扩 展到该索引值加 1

数组 length 属性的独特之处在于，它不是只读的。通过修改 length 属性，可以从数组末尾删除或添加元素

如果将 length 设置为大于数组元素数的值，则新添加的元素都将以 undefined 填充


### 检测数组
在只有一个网页(因而只有一个全局作 用域)的情况下，使用 instanceof 操作符就足矣
ECMAScript 提供了 Array.isArray()方法
```js
value instanceof Array

Array.isArray(value)
```

### 迭代器方法
在 ES6 中，Array 的原型上暴露了 3 个用于检索数组内容的方法:keys()、values()和 entries()